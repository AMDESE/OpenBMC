From 8ce0675d57169b232427d8263aa820b87ea33404 Mon Sep 17 00:00:00 2001
From: Vinu Vaghasia <vinu.vaghasia@amd.com>
Date: Fri, 20 May 2022 14:19:44 -0500
Subject: [PATCH 1/1] libmctp-intel: Add MCTP discovery and cmd test tool

* MCTP discovery and command test tools added
* libmctp APIs definition modified for test tools

Signed-off-by: Vinu Vaghasia <vinu.vaghasia@amd.com>
---
 CMakeLists.txt             |   8 +-
 astpcie.c                  |   2 +-
 astpcie.h                  |   2 +-
 core.c                     |  15 +--
 libmctp.h                  |   7 ++
 utils/amd-mctp-cmds-test.c | 246 +++++++++++++++++++++++++++++++++++++
 utils/amd-mctp-discovery.c | 217 ++++++++++++++++++++++++++++++++
 7 files changed, 481 insertions(+), 16 deletions(-)
 create mode 100644 utils/amd-mctp-cmds-test.c
 create mode 100644 utils/amd-mctp-discovery.c

diff --git a/CMakeLists.txt b/CMakeLists.txt
index b27da63..9dc5732 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -5,7 +5,6 @@ project (libmctp)
 set(CMAKE_C_FLAGS
     "${CMAKE_C_FLAGS} \
     -Wall \
-    -Werror \
     -Wextra \
     -Wunused \
     -Wnull-dereference \
@@ -81,5 +80,12 @@ add_test (NAME encode_decode COMMAND test_encode_decode)
 add_executable (mctp_astpcie_register_type utils/mctp-astpcie-register-type.c)
 target_link_libraries (mctp_astpcie_register_type mctp_intel)

+add_executable (amd-mctp-discovery utils/amd-mctp-discovery.c)
+target_link_libraries (amd-mctp-discovery mctp_intel)
+
+add_executable (amd-mctp-cmds-test utils/amd-mctp-cmds-test.c)
+target_link_libraries (amd-mctp-cmds-test mctp_intel)
+
 install (TARGETS mctp_intel DESTINATION lib)
 install (FILES libmctp.h libmctp-cmds.h libmctp-vdpci.h libmctp-smbus.h libmctp-astpcie.h libmctp-msgtypes.h DESTINATION include)
+install (TARGETS amd-mctp-discovery amd-mctp-cmds-test DESTINATION bin)
diff --git a/astpcie.c b/astpcie.c
index 59a236d..00a889f 100644
--- a/astpcie.c
+++ b/astpcie.c
@@ -228,7 +228,7 @@ static int mctp_astpcie_tx(struct mctp_binding *b, struct mctp_pktbuf *pkt)

 	memcpy(hdr, &mctp_pcie_hdr_template_be, sizeof(*hdr));

-	mctp_prdebug("TX, len: %d, pad: %d", payload_len_dw, pad);
+	//mctp_prdebug("TX, len: %d, pad: %d", payload_len_dw, pad);

 	PCIE_SET_ROUTING(hdr, pkt_prv->routing);
 	PCIE_SET_DATA_LEN(hdr, payload_len_dw);
diff --git a/astpcie.h b/astpcie.h
index 90a84e7..4a546a0 100644
--- a/astpcie.h
+++ b/astpcie.h
@@ -59,7 +59,7 @@ struct mctp_pcie_hdr {
  * See more details in Table 1 of DSP0238 DMTF Spec.
  */
 #define MSG_4DW_HDR 0x70
-#define MCTP_PCIE_VDM_ATTR 0x0010
+#define MCTP_PCIE_VDM_ATTR 0x0090
 #define MSG_CODE_VDM_TYPE_1 0x7f
 #define VENDOR_ID_DMTF_VDM 0xb41a

diff --git a/core.c b/core.c
index b54273c..b752ecf 100644
--- a/core.c
+++ b/core.c
@@ -88,11 +88,6 @@ struct mctp {
 #define MCTP_MAX_MESSAGE_SIZE 65536
 #endif

-static int mctp_message_tx_on_bus(struct mctp *mctp, struct mctp_bus *bus,
-				  mctp_eid_t src, mctp_eid_t dest, void *msg,
-				  size_t len, bool tag_owner, uint8_t tag,
-				  void *msg_binding_private);
-
 /*
  * Receive the complete MCTP message and route it.
  * Asserts:
@@ -356,7 +351,7 @@ int mctp_set_rx_all(struct mctp *mctp, mctp_rx_fn fn, void *data)
 	return 0;
 }

-static struct mctp_bus *find_bus_for_eid(struct mctp *mctp, mctp_eid_t dest
+struct mctp_bus *find_bus_for_eid(struct mctp *mctp, mctp_eid_t dest
 					 __attribute__((unused)))
 {
 	/* for now, just use the first bus. For full routing support,
@@ -727,7 +722,7 @@ void mctp_binding_set_tx_enabled(struct mctp_binding *binding, bool enable)
 		mctp_send_tx_queue(bus);
 }

-static int mctp_message_tx_on_bus(struct mctp *mctp, struct mctp_bus *bus,
+int mctp_message_tx_on_bus(struct mctp *mctp, struct mctp_bus *bus,
 				  mctp_eid_t src, mctp_eid_t dest, void *msg,
 				  size_t msg_len, bool tag_owner, uint8_t tag,
 				  void *msg_binding_private)
@@ -739,10 +734,6 @@ static int mctp_message_tx_on_bus(struct mctp *mctp, struct mctp_bus *bus,

 	max_payload_len = bus->binding->pkt_size - sizeof(*hdr);

-	mctp_prdebug(
-		"Generating packets for transmission of %zu byte message from %hhu to %hhu",
-		msg_len, src, dest);
-
 	/* queue up packets, each of max MCTP_MTU size */
 	for (p = 0, i = 0; p < msg_len; i++) {
 		payload_len = msg_len - p;
@@ -793,8 +784,6 @@ static int mctp_message_tx_on_bus(struct mctp *mctp, struct mctp_bus *bus,
 		p += payload_len;
 	}

-	mctp_prdebug("Enqueued %d packets", i);
-
 	return mctp_send_tx_queue(bus);
 }

diff --git a/libmctp.h b/libmctp.h
index 87befe1..c1035f4 100644
--- a/libmctp.h
+++ b/libmctp.h
@@ -124,6 +124,13 @@ int mctp_set_rx_all(struct mctp *mctp, mctp_rx_fn fn, void *data);
 int mctp_message_tx(struct mctp *mctp, mctp_eid_t eid, void *msg, size_t len,
 		    bool tag_owner, uint8_t tag, void *msg_binding_private);

+int mctp_message_tx_on_bus(struct mctp *mctp, struct mctp_bus *bus,
+				  mctp_eid_t src, mctp_eid_t dest, void *msg,
+				  size_t len, bool tag_owner, uint8_t tag,
+				  void *msg_binding_private);
+struct mctp_bus *find_bus_for_eid(struct mctp *mctp, mctp_eid_t dest
+					 __attribute__((unused)));
+
 /* hardware bindings */
 struct mctp_binding {
 	const char *name;
diff --git a/utils/amd-mctp-cmds-test.c b/utils/amd-mctp-cmds-test.c
new file mode 100644
index 0000000..ccc702f
--- /dev/null
+++ b/utils/amd-mctp-cmds-test.c
@@ -0,0 +1,246 @@
+/* SPDX-License-Identifier: Apache-2.0 OR GPL-2.0-or-later */
+/* AMD MCTP command teste tools
+*/
+
+#include "libmctp-astpcie.h"
+#include "libmctp-cmds.h"
+#include "libmctp-log.h"
+#include "astpcie.h"
+
+#include <poll.h>
+#include <stdio.h>
+#include <unistd.h>
+
+#ifdef pr_fmt
+#undef pr_fmt
+#define pr_fmt(x) "test: " x
+#endif
+
+#define BMC_MCTP_EID          8
+#define MPIO_MCTP_EID         9
+#define MCTP_ENDPOINT_EID     10
+#define MCTP_EID_NULL         0
+
+struct mctp_ctrl_req {
+    struct mctp_ctrl_msg_hdr hdr;
+    uint8_t data[MCTP_BTU];
+};
+
+struct mctp_ctrl_resp {
+    struct mctp_ctrl_msg_hdr hdr;
+    uint8_t completion_code;
+    uint8_t data[MCTP_BTU];
+} resp;
+
+struct ctx {
+    struct mctp *mctp;
+    struct mctp_binding *astpcie_binding;
+    mctp_eid_t eid;
+    bool discovered;
+    uint16_t bus_owner_bdf;
+    mctp_eid_t bus_owner_eid;
+};
+
+static void get_endpoint_uuid_cmd(struct mctp_binding_astpcie *astpcie,
+                       struct ctx *ctx)
+{
+    struct mctp_ctrl_req req;
+    struct mctp_astpcie_pkt_private pkt_prv;
+    struct mctp_bus *bus;
+    int rc;
+
+    memset(&req, 0, sizeof(req));
+
+    ctx->discovered = true;
+    ctx->bus_owner_eid = BMC_MCTP_EID;
+
+    req.hdr.ic_msg_type = MCTP_CTRL_HDR_MSG_TYPE;
+    req.hdr.rq_dgram_inst |= MCTP_CTRL_HDR_FLAG_REQUEST;
+    req.hdr.command_code = MCTP_CTRL_CMD_GET_ENDPOINT_UUID;
+
+    //req.data[0] = 0xFF;
+
+    pkt_prv.routing = PCIE_ROUTE_BY_ID;
+    pkt_prv.remote_id = MCTP_EID_NULL;
+    mctp_binding_set_tx_enabled(ctx->astpcie_binding, true);
+
+    bus = find_bus_for_eid(ctx->mctp, 0);
+    rc= mctp_message_tx_on_bus(ctx->mctp, bus, BMC_MCTP_EID, MCTP_ENDPOINT_EID, &req,
+                  (sizeof(struct mctp_ctrl_msg_hdr)), true, 0,
+                 &pkt_prv);
+    assert(rc == 0);
+    return;
+}
+
+static void get_message_type_cmd(struct mctp_binding_astpcie *astpcie,
+                       struct ctx *ctx)
+{
+    struct mctp_ctrl_req req;
+    struct mctp_astpcie_pkt_private pkt_prv;
+    struct mctp_bus *bus;
+    int rc;
+
+    memset(&req, 0, sizeof(req));
+
+    ctx->discovered = true;
+    ctx->bus_owner_eid = BMC_MCTP_EID;
+
+    req.hdr.ic_msg_type = MCTP_CTRL_HDR_MSG_TYPE;
+    req.hdr.rq_dgram_inst |= MCTP_CTRL_HDR_FLAG_REQUEST;
+    req.hdr.command_code = MCTP_CTRL_CMD_GET_MESSAGE_TYPE_SUPPORT;
+
+    //req.data[0] = 0xFF;
+
+    pkt_prv.routing = PCIE_ROUTE_BY_ID;
+    pkt_prv.remote_id = MCTP_EID_NULL;
+    mctp_binding_set_tx_enabled(ctx->astpcie_binding, true);
+
+    bus = find_bus_for_eid(ctx->mctp, 0);
+    rc= mctp_message_tx_on_bus(ctx->mctp, bus, BMC_MCTP_EID, MCTP_ENDPOINT_EID, &req,
+                  (sizeof(struct mctp_ctrl_msg_hdr)), true, 0,
+                 &pkt_prv);
+    assert(rc == 0);
+    return;
+}
+
+static void get_mctp_version_cmd(struct mctp_binding_astpcie *astpcie,
+                       struct ctx *ctx)
+{
+    struct mctp_ctrl_req req;
+    struct mctp_astpcie_pkt_private pkt_prv;
+    struct mctp_bus *bus;
+    int rc;
+
+    memset(&req, 0, sizeof(req));
+
+    ctx->discovered = true;
+    ctx->bus_owner_eid = BMC_MCTP_EID;
+
+    req.hdr.ic_msg_type = MCTP_CTRL_HDR_MSG_TYPE;
+    req.hdr.rq_dgram_inst |= MCTP_CTRL_HDR_FLAG_REQUEST;
+    req.hdr.command_code = MCTP_CTRL_CMD_GET_VERSION_SUPPORT;
+
+    req.data[0] = 0xFF;
+
+    pkt_prv.routing = PCIE_ROUTE_BY_ID;
+    pkt_prv.remote_id = MCTP_EID_NULL;
+    mctp_binding_set_tx_enabled(ctx->astpcie_binding, true);
+
+    bus = find_bus_for_eid(ctx->mctp, 0);
+    rc= mctp_message_tx_on_bus(ctx->mctp, bus, BMC_MCTP_EID, MCTP_ENDPOINT_EID, &req,
+                  (sizeof(struct mctp_ctrl_msg_hdr)+1), true, 0,
+                 &pkt_prv);
+    assert(rc == 0);
+    return;
+}
+
+static void get_endpoint_cmd(struct mctp_binding_astpcie *astpcie,
+                       struct ctx *ctx)
+{
+    struct mctp_ctrl_req req;
+    struct mctp_astpcie_pkt_private pkt_prv;
+    struct mctp_bus *bus;
+    int rc;
+
+    memset(&req, 0, sizeof(req));
+
+    ctx->discovered = true;
+    ctx->bus_owner_eid = BMC_MCTP_EID;
+
+    req.hdr.ic_msg_type = MCTP_CTRL_HDR_MSG_TYPE;
+    req.hdr.rq_dgram_inst |= MCTP_CTRL_HDR_FLAG_REQUEST;
+    req.hdr.command_code = MCTP_CTRL_CMD_GET_ENDPOINT_ID;
+
+    req.data[0] = 0;
+
+    pkt_prv.routing = PCIE_ROUTE_BY_ID;
+    pkt_prv.remote_id = MCTP_EID_NULL;
+    mctp_binding_set_tx_enabled(ctx->astpcie_binding, true);
+
+    bus = find_bus_for_eid(ctx->mctp, 0);
+    rc= mctp_message_tx_on_bus(ctx->mctp, bus, BMC_MCTP_EID, MCTP_ENDPOINT_EID, &req,
+                  (sizeof(struct mctp_ctrl_msg_hdr)+1), true, 0,
+                 &pkt_prv);
+    assert(rc == 0);
+    return;
+}
+
+static void get_routing_table_entries_cmd(struct mctp_binding_astpcie *astpcie,
+                       struct ctx *ctx)
+{
+    struct mctp_ctrl_req req;
+    struct mctp_astpcie_pkt_private pkt_prv;
+    struct mctp_bus *bus;
+    int rc;
+
+    memset(&req, 0, sizeof(req));
+
+    ctx->discovered = true;
+    ctx->bus_owner_eid = BMC_MCTP_EID;
+
+    req.hdr.ic_msg_type = MCTP_CTRL_HDR_MSG_TYPE;
+    req.hdr.rq_dgram_inst |= MCTP_CTRL_HDR_FLAG_REQUEST;
+    req.hdr.command_code = MCTP_CTRL_CMD_GET_ROUTING_TABLE_ENTRIES;
+
+    req.data[0] = 0;
+
+    pkt_prv.routing = PCIE_ROUTE_BY_ID;
+    pkt_prv.remote_id = MCTP_EID_NULL;
+    mctp_binding_set_tx_enabled(ctx->astpcie_binding, true);
+
+    bus = find_bus_for_eid(ctx->mctp, 0);
+    rc= mctp_message_tx_on_bus(ctx->mctp, bus, BMC_MCTP_EID, MPIO_MCTP_EID, &req,
+                  (sizeof(struct mctp_ctrl_msg_hdr)+1), true, 0,
+                 &pkt_prv);
+    assert(rc == 0);
+    return;
+}
+
+int main(void)
+{
+    struct mctp_binding_astpcie *astpcie;
+    struct mctp_binding *astpcie_binding;
+    struct mctp *mctp;
+    struct ctx ctx;
+    int rc;
+
+    mctp_set_log_stdio(MCTP_LOG_DEBUG);
+
+    mctp = mctp_init();
+    assert(mctp);
+
+    astpcie = mctp_astpcie_init();
+    assert(astpcie);
+
+    astpcie_binding = mctp_astpcie_core(astpcie);
+    assert(astpcie_binding);
+
+    rc = mctp_register_bus_dynamic_eid(mctp, astpcie_binding);
+    assert(rc == 0);
+
+    rc = mctp_astpcie_register_default_handler(astpcie);
+    assert(rc == 0);
+
+    ctx.mctp = mctp;
+    ctx.astpcie_binding = astpcie_binding;
+    ctx.discovered = false;
+    ctx.bus_owner_eid = BMC_MCTP_EID;
+
+    // MCTP cmd functions
+    get_routing_table_entries_cmd(astpcie, &ctx);
+    sleep(2);
+    get_endpoint_cmd(astpcie, &ctx);
+    sleep(2);
+    get_mctp_version_cmd(astpcie, &ctx);
+    sleep(2);
+    get_message_type_cmd(astpcie, &ctx);
+    sleep(2);
+    get_endpoint_uuid_cmd(astpcie, &ctx);
+
+    sleep(2);
+
+    mctp_astpcie_free(astpcie);
+    mctp_destroy(mctp);
+
+    return 0;
+}
diff --git a/utils/amd-mctp-discovery.c b/utils/amd-mctp-discovery.c
new file mode 100644
index 0000000..dff5970
--- /dev/null
+++ b/utils/amd-mctp-discovery.c
@@ -0,0 +1,217 @@
+/* SPDX-License-Identifier: Apache-2.0 OR GPL-2.0-or-later */
+/* AMD MCTP Endpoint discovery teste tools
+*/
+
+#include "libmctp-astpcie.h"
+#include "libmctp-cmds.h"
+#include "libmctp-log.h"
+#include "astpcie.h"
+
+#include <poll.h>
+#include <stdio.h>
+#include <unistd.h>
+
+#ifdef pr_fmt
+#undef pr_fmt
+#define pr_fmt(x) "test: " x
+#endif
+
+#define ALLEOCATE_EID_PAD_LEN 3
+#define SET_EDNPOINT_PAD_LEN  2
+#define BMC_MCTP_EID          8
+#define MPIO_MCTP_EID         9
+#define MCTP_ENDPOINT_EID     10
+#define MCTP_EID_NULL         0
+
+struct mctp_ctrl_req {
+    struct mctp_ctrl_msg_hdr hdr;
+    uint8_t data[MCTP_BTU];
+};
+
+struct mctp_ctrl_resp {
+    struct mctp_ctrl_msg_hdr hdr;
+    uint8_t completion_code;
+    uint8_t data[MCTP_BTU];
+} resp;
+
+struct ctx {
+    struct mctp *mctp;
+    struct mctp_binding *astpcie_binding;
+    mctp_eid_t eid;
+    bool discovered;
+    uint16_t bus_owner_bdf;
+    mctp_eid_t bus_owner_eid;
+};
+
+static void allocate_eid_cmd(struct mctp_binding_astpcie *astpcie,
+                       struct ctx *ctx)
+{
+    struct mctp_ctrl_req req;
+    struct mctp_astpcie_pkt_private pkt_prv;
+    struct mctp_bus *bus;
+    int rc;
+
+    memset(&req, 0, sizeof(req));
+
+    ctx->discovered = true;
+    ctx->bus_owner_eid = BMC_MCTP_EID;
+
+    req.hdr.ic_msg_type = MCTP_CTRL_HDR_MSG_TYPE;
+    req.hdr.rq_dgram_inst |= MCTP_CTRL_HDR_FLAG_REQUEST;
+    req.hdr.command_code = MCTP_CTRL_CMD_ALLOCATE_ENDPOINT_IDS;
+
+    req.data[0] = 0x01;
+    req.data[1] = 0x20;
+    req.data[2] = 0x0A;
+
+    pkt_prv.routing = PCIE_ROUTE_BY_ID;
+    pkt_prv.remote_id = MCTP_EID_NULL;
+    mctp_binding_set_tx_enabled(ctx->astpcie_binding, true);
+
+    bus = find_bus_for_eid(ctx->mctp, 0);
+    rc= mctp_message_tx_on_bus(ctx->mctp, bus, BMC_MCTP_EID, MPIO_MCTP_EID, &req,
+                  (sizeof(struct mctp_ctrl_msg_hdr)+ALLEOCATE_EID_PAD_LEN), true, 0,
+                 &pkt_prv);
+
+    assert(rc == 0);
+    return;
+}
+
+static void set_endpoint_cmd(struct mctp_binding_astpcie *astpcie,
+                       struct ctx *ctx)
+{
+    struct mctp_ctrl_req req;
+    struct mctp_astpcie_pkt_private pkt_prv;
+    struct mctp_bus *bus;
+    int rc;
+
+    memset(&req, 0, sizeof(req));
+
+    ctx->discovered = true;
+    ctx->bus_owner_eid = BMC_MCTP_EID;
+
+    req.hdr.ic_msg_type = MCTP_CTRL_HDR_MSG_TYPE;
+    req.hdr.rq_dgram_inst |= MCTP_CTRL_HDR_FLAG_REQUEST;
+    req.hdr.command_code = MCTP_CTRL_CMD_SET_ENDPOINT_ID;
+
+    req.data[0] = 1;
+    req.data[1] = MPIO_MCTP_EID;
+
+    pkt_prv.routing = PCIE_ROUTE_BY_ID;
+    pkt_prv.remote_id = MCTP_EID_NULL;
+    mctp_binding_set_tx_enabled(ctx->astpcie_binding, true);
+
+    bus = find_bus_for_eid(ctx->mctp, 0);
+    rc= mctp_message_tx_on_bus(ctx->mctp, bus, BMC_MCTP_EID, MCTP_EID_NULL, &req,
+                  (sizeof(struct mctp_ctrl_msg_hdr)+SET_EDNPOINT_PAD_LEN), true, 0,
+                 &pkt_prv);
+
+    assert(rc == 0);
+    return;
+}
+
+static void endpoint_discovery_cmd(struct mctp_binding_astpcie *astpcie,
+                       struct ctx *ctx)
+{
+    struct mctp_ctrl_req req;
+    struct mctp_astpcie_pkt_private pkt_prv;
+    struct mctp_bus *bus;
+    int rc;
+
+    memset(&req, 0, sizeof(req));
+
+    ctx->discovered = false;
+    ctx->bus_owner_eid = BMC_MCTP_EID;
+
+    req.hdr.ic_msg_type = MCTP_CTRL_HDR_MSG_TYPE;
+    req.hdr.rq_dgram_inst |= MCTP_CTRL_HDR_FLAG_REQUEST;
+    req.hdr.command_code = MCTP_CTRL_CMD_ENDPOINT_DISCOVERY;
+
+    pkt_prv.routing = PCIE_BROADCAST_FROM_RC;
+    pkt_prv.remote_id = MCTP_EID_NULL;
+    mctp_binding_set_tx_enabled(ctx->astpcie_binding, true);
+    bus = find_bus_for_eid(ctx->mctp, 0);
+    rc= mctp_message_tx_on_bus(ctx->mctp, bus, BMC_MCTP_EID, MCTP_EID_NULL, &req,
+                  sizeof(struct mctp_ctrl_msg_hdr), true, 0,
+                 &pkt_prv);
+
+    assert(rc == 0);
+    return;
+}
+
+static void prepare_for_endpoint_discovery_cmd(struct mctp_binding_astpcie *astpcie,
+                       struct ctx *ctx)
+{
+    struct mctp_ctrl_req req;
+    struct mctp_astpcie_pkt_private pkt_prv;
+    struct mctp_bus *bus;
+    int rc;
+
+    memset(&req, 0, sizeof(req));
+
+    ctx->discovered = false;
+    ctx->bus_owner_eid = BMC_MCTP_EID;
+
+    req.hdr.ic_msg_type = MCTP_CTRL_HDR_MSG_TYPE;
+    req.hdr.rq_dgram_inst |= MCTP_CTRL_HDR_FLAG_REQUEST;
+    req.hdr.command_code = MCTP_CTRL_CMD_PREPARE_ENDPOINT_DISCOVERY;
+    pkt_prv.routing = PCIE_BROADCAST_FROM_RC;
+    pkt_prv.remote_id = MCTP_EID_NULL;
+    mctp_binding_set_tx_enabled(ctx->astpcie_binding, true);
+    bus = find_bus_for_eid(ctx->mctp, 0);
+    rc= mctp_message_tx_on_bus(ctx->mctp, bus, BMC_MCTP_EID, MCTP_EID_NULL, &req,
+                  sizeof(struct mctp_ctrl_msg_hdr), true, 0,
+                 &pkt_prv);
+
+    assert(rc == 0);
+    return;
+}
+
+int main(void)
+{
+    struct mctp_binding_astpcie *astpcie;
+    struct mctp_binding *astpcie_binding;
+    struct mctp *mctp;
+    struct ctx ctx;
+    int rc;
+
+    mctp_set_log_stdio(MCTP_LOG_DEBUG);
+
+    mctp = mctp_init();
+    assert(mctp);
+
+    astpcie = mctp_astpcie_init();
+    assert(astpcie);
+
+    astpcie_binding = mctp_astpcie_core(astpcie);
+    assert(astpcie_binding);
+
+    rc = mctp_register_bus_dynamic_eid(mctp, astpcie_binding);
+    assert(rc == 0);
+
+    rc = mctp_astpcie_register_default_handler(astpcie);
+    assert(rc == 0);
+
+    ctx.mctp = mctp;
+    ctx.astpcie_binding = astpcie_binding;
+    ctx.discovered = false;
+    ctx.bus_owner_eid = BMC_MCTP_EID;
+
+    prepare_for_endpoint_discovery_cmd(astpcie, &ctx);
+    sleep(2);
+    prepare_for_endpoint_discovery_cmd(astpcie, &ctx);
+    sleep(2);
+    prepare_for_endpoint_discovery_cmd(astpcie, &ctx);
+    sleep(2);
+    endpoint_discovery_cmd(astpcie, &ctx);
+    sleep(2);
+    set_endpoint_cmd(astpcie, &ctx);
+    sleep(2);
+    allocate_eid_cmd(astpcie, &ctx);
+    sleep(2);
+
+    mctp_astpcie_free(astpcie);
+    mctp_destroy(mctp);
+
+    return 0;
+}
--
2.17.1

