From 253f562835c1f5697f92e80c4fe86a26738a419d Mon Sep 17 00:00:00 2001
From: Vinu Vaghasia <vinu.vaghasia@amd.com>
Date: Wed, 20 Oct 2021 13:11:26 -0500
Subject: [PATCH 1/1] amd-power-control: Add APML MUX setting code

This code will enable the APML i2c bus MUX on every host power ON event
so, BMC can read the sb-tsi and sb-rmi registers

Signed-off-by: Vinu Vaghasia <vinu.vaghasia@amd.com>
---
 power-control-x86/src/power_control.cpp | 111 ++++++++++++++++++++++++
 1 file changed, 111 insertions(+)

diff --git a/power-control-x86/src/power_control.cpp b/power-control-x86/src/power_control.cpp
index 0aa6b8d..022e4c4 100644
--- a/power-control-x86/src/power_control.cpp
+++ b/power-control-x86/src/power_control.cpp
@@ -34,6 +34,38 @@
 #include <iostream>
 #include <string_view>

+constexpr auto ONYX_SLT     = 61;   //0x3D
+constexpr auto ONYX_1       = 64;   //0x40
+constexpr auto ONYX_2       = 65;   //0x41
+constexpr auto ONYX_3       = 66;   //0x42
+constexpr auto ONYX_FR4     = 82;   //0x52
+constexpr auto QUARTZ_DAP   = 62;   //0x3E
+constexpr auto QUARTZ_1     = 67;   //0x43
+constexpr auto QUARTZ_2     = 68;   //0x44
+constexpr auto QUARTZ_3     = 69;   //0x45
+constexpr auto QUARTZ_FR4   = 81;   //0x51
+constexpr auto RUBY_1       = 70;   //0x46
+constexpr auto RUBY_2       = 71;   //0x47
+constexpr auto RUBY_3       = 72;   //0x48
+constexpr auto TITANITE_1   = 73;   //0x49
+constexpr auto TITANITE_2   = 74;   //0x4A
+constexpr auto TITANITE_3   = 75;   //0x4B
+constexpr auto TITANITE_4   = 76;   //0x4C
+constexpr auto TITANITE_5   = 77;   //0x4D
+constexpr auto TITANITE_6   = 78;   //0x4E
+
+#define COMMAND_BOARD_ID    ("/sbin/fw_printenv -n board_id")
+#define COMMAND_OUTPUT_LEN  (8)
+
+/* Definition for APML Mux setting */
+#define I2C_MUX         0x70
+#define I2C_MUX_MR46    0x46
+#define I2C_MUX_MR64    0x40  // MUX port sel
+#define I2C_MUX_MR65    0x41  // MUX port rw enable
+#define CMD_BUFF_LEN    64
+#define BDID_BUFF_LEN   8
+
+
 namespace power_control
 {
 static boost::asio::io_service io;
@@ -103,6 +135,81 @@ enum class PowerState
     checkForWarmReset,
 };

+/* Read platform ID from env */
+static bool getPlatformID(char *data)
+{
+    FILE *pf;
+    // Setup pipe for reading and execute to get u-boot environment variable board_id.
+    pf = popen(COMMAND_BOARD_ID,"r");
+    if(pf < 0)
+    {
+        std::cerr << "Unable to read Board ID from env" << "\n";
+        return false;
+    }
+    // Get the data from the process execution
+    if (fgets(data, COMMAND_OUTPUT_LEN , pf) == NULL)
+    {
+        std::cerr << "Board ID is not set in env" << "\n";
+        return false;
+    }
+    // the data is now in 'data'
+    if (pclose(pf) != 0)
+    {
+        std::cerr << "Failed to close command stream" << "\n";
+        return false;
+    }
+    return true;
+}
+
+static void resetAPMLMuxChannel()
+{
+    char cmd[CMD_BUFF_LEN];
+    char data[BDID_BUFF_LEN];
+    unsigned int board_id;
+    std::stringstream ss;
+    int num_of_apml_bus=2;  /* Default num of bus = 2 */
+    int apml_bus=2;         /* start with APML bus 2 */
+
+    /* Code for APML bus Mux settings */
+    if (power_control::psPowerOKLine.get_value() > 0)
+    {
+        if (getPlatformID(data))
+        {
+            ss << std::hex << (std::string)data;
+            ss >> board_id;
+            switch (board_id)
+            {
+                case ONYX_SLT:
+                case ONYX_FR4:
+                case ONYX_1 ... ONYX_3:
+                case RUBY_1 ... RUBY_3:
+                    /* For Onyx and Ruby 1P systems */
+                    num_of_apml_bus = 1;
+                    break;
+                default:
+                    /* For Quartz and Titanite 2P systems */
+                    num_of_apml_bus = 2;
+                    break;
+            }//switch
+        }
+        for  ( int i=0; i<num_of_apml_bus; i++)
+        {
+            std::cout << "Setting APML Mux registers on i2c bus " << apml_bus << std::endl;
+            sprintf(cmd, "i2cset -f -y %d 0x%02x 0x%02x 0x01 >& /dev/null\n", apml_bus, I2C_MUX, I2C_MUX_MR46);
+            if (system(cmd) != 0)
+                std::cout <<"Failed to set APML MUX on bus " << apml_bus << " reg 0x" << I2C_MUX_MR46 << " OR no CPU installed" << "\n";
+            sprintf(cmd, "i2cset -f -y %d 0x%02x 0x%02x 0x40 >& /dev/null\n", apml_bus, I2C_MUX, I2C_MUX_MR64);
+            if (system(cmd) != 0)
+                std::cout <<"Failed to set APML MUX on bus " << apml_bus << " reg 0x" << I2C_MUX_MR64 << " OR no CPU installed" << "\n";
+            sprintf(cmd, "i2cset -f -y %d 0x%02x 0x%02x 0x40 >& /dev/null\n", apml_bus, I2C_MUX, I2C_MUX_MR65);
+            if (system(cmd) != 0)
+                std::cout <<"Failed to set APML MUX on bus " << apml_bus << " reg 0x" << I2C_MUX_MR65<< " OR no CPU installed" << "\n";
+            apml_bus++;
+        }
+    }
+    return;
+}
+
 static int getGPIOValue(const std::string& name)
 {
     int value;
@@ -1249,6 +1356,10 @@ static void psPowerOKHandler()
             : Event::psPowerOKDeAssert;

     sendPowerControlEvent(powerControlEvent);
+
+    /* Reset the APML Mux channel with each power on event */
+    resetAPMLMuxChannel();
+
     psPowerOKEvent.async_wait(
         boost::asio::posix::stream_descriptor::wait_read,
         [](const boost::system::error_code ec) {
--
2.17.1

