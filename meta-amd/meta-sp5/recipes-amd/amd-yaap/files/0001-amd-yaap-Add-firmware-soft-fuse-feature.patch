From 6a516733c7881369a27bd444844f96b381255009 Mon Sep 17 00:00:00 2001
From: Supreeth Venkatesh <supreeth.venkatesh@amd.com>
Date: Thu, 5 Aug 2021 00:10:57 -0500
Subject: [PATCH 1/1] amd-yaap: Add firmware soft fuse feature
Content-Type: text/plain; charset="us-ascii"
Content-Transfer-Encoding: 7bit

Adds support for firmware soft fuse feature.

Signed-off-by: Supreeth Venkatesh <supreeth.venkatesh@amd.com>
---
 Source/Linux/bmc/Makefile         |  5 ++-
 Source/Linux/bmc/hw/jtag_hw.cpp   | 59 ++++++++++++++++++++++------
 Source/Linux/bmc/hw/jtag_hw.h     |  1 +
 Source/Linux/bmc/hw/psp_sfmon.cpp | 64 +++++++++++++++++++++++++++++++
 Source/Linux/bmc/hw/psp_sfmon.h   | 64 +++++++++++++++++++++++++++++++
 Source/Linux/bmc/main.cpp         | 21 +++++++++-
 coolreset.txt                     | 15 ++++++++
 7 files changed, 215 insertions(+), 14 deletions(-)
 create mode 100644 Source/Linux/bmc/hw/psp_sfmon.cpp
 create mode 100644 Source/Linux/bmc/hw/psp_sfmon.h
 create mode 100644 coolreset.txt

diff --git a/Source/Linux/bmc/Makefile b/Source/Linux/bmc/Makefile
index 9560ca2..4edf59d 100644
--- a/Source/Linux/bmc/Makefile
+++ b/Source/Linux/bmc/Makefile
@@ -77,7 +77,8 @@ OBJS += main.o \
 	hw/gpuDebug_hw.o \
 	hw/lpcPostCode_hw.o \
 	hw/lpcRomEmu_hw.o \
-	hw/mux_hw.o
+	hw/mux_hw.o \
+	hw/psp_sfmon.o

 all: $(APP)

@@ -85,7 +86,7 @@ DEP_FILES = $(OBJS:.o=.d)
 include $(DEP_FILES)

 $(APP): $(OBJS)
-	$(CXX) $(LDFLAGS) -o $@ $(OBJS) $(LDLIBS) $(LDADD) -L$(PWD)/../../../recipe-sysroot/usr/lib -lgpiodcxx
+	$(CXX) $(LDFLAGS) -o $@ $(OBJS) $(LDLIBS) $(LDADD) -L$(PWD)/../../../recipe-sysroot/usr/lib -lgpiodcxx -pthread

 %.d: %.c
 	$(CC) -MM -MT "$*.o" -MT "$*.d" $(CFLAGS) $< > $@
diff --git a/Source/Linux/bmc/hw/jtag_hw.cpp b/Source/Linux/bmc/hw/jtag_hw.cpp
index 494a625..ef8597e 100644
--- a/Source/Linux/bmc/hw/jtag_hw.cpp
+++ b/Source/Linux/bmc/hw/jtag_hw.cpp
@@ -74,25 +74,62 @@
 #include <stdio.h>
 #include "infrastructure/debug.h"

+#define  COOL_RESET_MAX_SIZE  (64)

 int bmc::JtagHw::default_jtag_xfer_mode = JTAG_XFER_HW_MODE;

 int printx(const char *msg,unsigned char *x, int len)
-{    int i=0,j=0;
-DEBUG_PRINT(DEBUG_INFO,"\n%s %d bytes\n",msg,len);
-for(i=0;i<len;i=i+16){
-    if((len - i) > 15)
-     DEBUG_PRINT(DEBUG_INFO, "%02x %02x  %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x \n", x[i+0],x[i+1],x[i+2],x[i+3],x[i+4],x[i+5],x[i+6],x[i+7],x[i+8],x[i+9],x[i+10],x[i+11],x[i+12],x[i+13],x[i+14],x[i+15]);
-    else {
-          for(j=0;j<(len-i);j++)
-              DEBUG_PRINT(DEBUG_INFO,"%02x ",x[i+j]);
-          DEBUG_PRINT(DEBUG_INFO," \n");
+{
+    int i=0,j=0;
+    DEBUG_PRINT(DEBUG_INFO,"\n%s %d bytes\n",msg,len);
+    for(i=0;i<len;i=i+16){
+        if((len - i) > 15)
+            DEBUG_PRINT(DEBUG_INFO, "%02x %02x  %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x \n", x[i+0],x[i+1],x[i+2],x[i+3],x[i+4],x[i+5],x[i+6],x[i+7],x[i+8],x[i+9],x[i+10],x[i+11],x[i+12],x[i+13],x[i+14],x[i+15]);
+        else {
+            for(j=0;j<(len-i);j++)
+                DEBUG_PRINT(DEBUG_INFO,"%02x ",x[i+j]);
+            DEBUG_PRINT(DEBUG_INFO," \n");
+        }
     }
-}
-return 0;
+    return 0;
 }

+void bmc::JtagHw::coolreset()
+{
+    uint8_t inData[COOL_RESET_MAX_SIZE] = {0};
+    uint8_t outData[COOL_RESET_MAX_SIZE] = {0};
+    uint8_t operation = 0;
+    int     bits = 0;
+    FILE *file;
+    enum yaap::hal::jtagOp op;
+
+    // Enable jtag mux
+    setGPIOValue(hdtSelName, 1);
+    // Reset Tap State
+    tapStateSet(yaap::hal::JTAG_STATE_TLR);
+
+    file = fopen("/etc/amd-yaap/coolreset.txt", "r");
+    while(!feof(file))
+    {
+      fscanf(file, "%x\t%d\t", &operation, &bits);
+      int bytes = ((bits + 7) >> 3);
+      for (int i = 0; i < bytes; i++)
+      {
+        fscanf(file, "%x\t", &inData[i]);
+      }
+      fscanf(file, "\n");
+      op = (operation == 0)? (yaap::hal::JTAG_OP_SHIFT_IR) : (yaap::hal::JTAG_OP_SHIFT_DR);
+      std::string message = "Cool Reset Input Data";
+      //printx(message.c_str(), inData, bytes);
+      shift(op, inData, outData, bits, 0, 0, yaap::hal::JTAG_STATE_RTI);
+
+      memset (&inData[0], 0, COOL_RESET_MAX_SIZE);
+      memset (&outData[0], 0, COOL_RESET_MAX_SIZE);
+    }

+    // Release Jtag mux
+    setGPIOValue(hdtSelName, 0);
+}

 bmc::JtagHw::JtagHw(int driver)
     : m_freq(8250000), m_state(yaap::hal::JTAG_STATE_TLR)
diff --git a/Source/Linux/bmc/hw/jtag_hw.h b/Source/Linux/bmc/hw/jtag_hw.h
index 7e07e9a..afd5ea5 100644
--- a/Source/Linux/bmc/hw/jtag_hw.h
+++ b/Source/Linux/bmc/hw/jtag_hw.h
@@ -86,6 +86,7 @@ class JtagHw : public IJtag, public IJtag_tapState, public IJtag_tckFrequency
     uint32_t tapStateGet(enum yaap::hal::jtagState& state);
     uint32_t tckFreqSet(uint32_t& freqHz);
     uint32_t tckFreqGet(uint32_t& freqHz);
+    void coolreset();

     static int default_jtag_xfer_mode;
 };
diff --git a/Source/Linux/bmc/hw/psp_sfmon.cpp b/Source/Linux/bmc/hw/psp_sfmon.cpp
new file mode 100644
index 0000000..d9dcacf
--- /dev/null
+++ b/Source/Linux/bmc/hw/psp_sfmon.cpp
@@ -0,0 +1,64 @@
+#include "psp_sfmon.h"
+
+void pspSfMonitor::scheduleEventHandler()
+{
+
+    DEBUG_PRINT(DEBUG_INFO, "pspSfMonitor scheduleEventHandler()\n");
+    gpioEventDescriptor.async_wait(
+        boost::asio::posix::stream_descriptor::wait_read,
+        [this](const boost::system::error_code& ec) {
+            if (ec)
+            {
+                std::string msg = "event handler error" +
+                                  std::string(ec.message());
+                DEBUG_PRINT(DEBUG_FATAL, "%s\n", msg.c_str());
+                return;
+            }
+            gpioEventHandler();
+        });
+}
+
+void pspSfMonitor::gpioEventHandler()
+{
+    gpiod::line_event gpioLineEvent = gpioLine.event_read();
+
+    DEBUG_PRINT(DEBUG_INFO, "PSP Soft Fuse Notify Event Received\n");
+
+    if (gpioLineEvent.event_type == gpiod::line_event::RISING_EDGE)
+    {
+        coolresetJtagHw->coolreset();
+    }
+
+    /* Schedule a wait event */
+    scheduleEventHandler();
+}
+
+void pspSfMonitor::requestGPIOEvents()
+{
+
+    DEBUG_PRINT(DEBUG_INFO, "pspSfMonitor requestGPIOEvents()\n");
+    /* Request an event to monitor for respected gpio line */
+    try {
+        gpioLine.request( { "yaapd", gpiod::line_request::EVENT_BOTH_EDGES });
+    }
+    catch (std::exception &exc) {
+        DEBUG_PRINT(DEBUG_FATAL, "Failed to request gpioLineEvent\n");
+        //return -1;
+    }
+
+    int gpioLineFd = gpioLine.event_get_fd();
+    if (gpioLineFd < 0)
+    {
+        DEBUG_PRINT(DEBUG_FATAL, "Failed to get fd for gpioLineEvent\n");
+        //return -1;
+    }
+
+
+    /* Assign line fd to descriptor for monitoring */
+    gpioEventDescriptor.assign(gpioLineFd);
+
+    /* Schedule a wait event */
+    scheduleEventHandler();
+
+    io_service.run();
+}
diff --git a/Source/Linux/bmc/hw/psp_sfmon.h b/Source/Linux/bmc/hw/psp_sfmon.h
new file mode 100644
index 0000000..6f9cd81
--- /dev/null
+++ b/Source/Linux/bmc/hw/psp_sfmon.h
@@ -0,0 +1,64 @@
+#include <gpiod.hpp>
+
+#include <boost/asio/io_service.hpp>
+#include <boost/asio/posix/stream_descriptor.hpp>
+
+#include "jtag_hw.h"
+#include "infrastructure/debug.h"
+
+/** @class pspSfMonitor
+ *  @brief Responsible for catching GPIO state change
+ *  condition.
+ */
+
+class pspSfMonitor
+{
+  public:
+    pspSfMonitor() = delete;
+    ~pspSfMonitor() = default;
+    pspSfMonitor(const pspSfMonitor&) = delete;
+    pspSfMonitor& operator=(const pspSfMonitor&) = delete;
+    pspSfMonitor(pspSfMonitor&&) = delete;
+    pspSfMonitor& operator=(pspSfMonitor&&) = delete;
+
+    /** @brief Constructs pspSfMonitor object.
+     *
+     *  @param[in] line        - GPIO line from libgpiod
+     *  @param[in] io          - io service
+     *  @param[in] jtagHw      - coolreset object
+     */
+    pspSfMonitor( gpiod::line& line,
+                  bmc::JtagHw *cpuDebugJtagHw
+                ):gpioEventDescriptor(io_service)
+    {
+        gpioLine = line;
+        coolresetJtagHw = cpuDebugJtagHw;
+        DEBUG_PRINT(DEBUG_INFO, "pspSfMonitor Constructor()\n");
+    };
+
+  private:
+    /** @brief boost IO service */
+    boost::asio::io_service io_service;
+
+    /** @brief GPIO line */
+    gpiod::line gpioLine;
+
+    /** @brief GPIO line */
+    bmc::JtagHw *coolresetJtagHw;
+
+    /** @brief GPIO event descriptor */
+    boost::asio::posix::stream_descriptor gpioEventDescriptor;
+
+    /** @brief Schedule an event handler for GPIO event to trigger */
+    void scheduleEventHandler();
+
+    /** @brief Handle the GPIO event and starts configured target */
+    void gpioEventHandler();
+
+  public:
+    /** @brief register handler for gpio event
+     *
+     *  @return  - 0 on success and -1 otherwise
+     */
+    void requestGPIOEvents();
+};
diff --git a/Source/Linux/bmc/main.cpp b/Source/Linux/bmc/main.cpp
index dd54c51..e372865 100644
--- a/Source/Linux/bmc/main.cpp
+++ b/Source/Linux/bmc/main.cpp
@@ -58,6 +58,8 @@
  ******************************************************************************/

 #include <fcntl.h>
+
+#include <thread>
 #include <gpiod.hpp>
 #include <system_error>

@@ -87,6 +89,7 @@
 #include "hw/lpcRomEmu_hw.h"

 #include "hw/mux_hw.h"
+#include "hw/psp_sfmon.h"

 #include "infrastructure/socketHandler.h"

@@ -102,7 +105,6 @@ const std::string warmResetButtonName = "ASSERT_WARM_RST_BTN_L";
 const std::string fpgaReservedButtonName = "ASSERT_SOC_RST_BTN_L";
 const std::string jtagTRSTName = "JTAG_TRST_N";

-
 #ifndef CONSUMER
 #define CONSUMER "Consumer"
 #endif
@@ -194,6 +196,9 @@ int main(int argc, char *argv[])
     int yaapPort = DEFAULT_YAAP_PORT;
     int yaapTimeout = -1;

+    boost::asio::io_service io;
+    const std::string pspSFName = "PSP_SOFT_FUSE_NOTIFY";
+
     // Parse command line
     if (argc > 1) {
         for (i = 0; i < argc; i++) {
@@ -283,6 +288,20 @@ int main(int argc, char *argv[])
         socketHandler::setConnectionTimeout(yaapTimeout);
     }

+    gpiod::line gpioLine;
+
+    gpioLine = gpiod::find_line(pspSFName);
+    if (!gpioLine)
+    {
+       	DEBUG_PRINT(DEBUG_FATAL, "Failed to find the: %s line\n", pspSFName.c_str());
+        return false;
+    }
+
+    DEBUG_PRINT(DEBUG_INFO, "creating PSP Soft Fuse Notify Monitor Object\n");
+    pspSfMonitor *pspSfMonObj = new pspSfMonitor(gpioLine, &cpuDebugJtagHw);
+    std::thread th(&pspSfMonitor::requestGPIOEvents, pspSfMonObj);
+    th.detach();
+
     // Start the YAAP server...
     return startServer(yaapPort, __debugLevel__);
 }
diff --git a/coolreset.txt b/coolreset.txt
new file mode 100644
index 0000000..8304467
--- /dev/null
+++ b/coolreset.txt
@@ -0,0 +1,15 @@
+0	8	03	
+1	6	01	
+0	8	13	
+1	2	01	
+1	11	13	02	
+1	17	00	88	00	
+1	26	13	00	10	01	
+1	62	00	00	00	00	20	00	00	11	
+1	71	03	00	00	00	00	40	00	00	22	
+1	66	01	00	00	00	00	02	00	10	01	
+1	76	9F	05	00	00	00	00	08	00	40	04	
+1	77	0D	08	00	00	00	00	10	00	80	08	
+1	77	05	08	00	00	00	00	10	00	80	08	
+1	77	06	08	00	00	00	00	10	00	80	08	
+1	77	0A	44	00	00	00	00	00	08	00	0C	
--
2.17.1

