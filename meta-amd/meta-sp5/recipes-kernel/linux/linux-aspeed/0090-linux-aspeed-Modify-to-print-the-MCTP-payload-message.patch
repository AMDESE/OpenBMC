From 965b09efa66c0e108fa81174fceb86b02eee026d Mon Sep 17 00:00:00 2001
From: Vinu Vaghasia <vinu.vaghasia@amd.com>
Date: Fri, 20 May 2022 15:24:59 -0500
Subject: [PATCH 1/1] linux-aspeed: Modify to print the MCTP payload messages

Code added to pring the MCTP payload info for debugging only.
This is temporary code will be removed once implemented at
application layer.

Signed-off-by: Vinu Vaghasia <vinu.vaghasia@amd.com>
---
 drivers/soc/aspeed/aspeed-mctp.c | 370 +++++++++++++++++++++++++++++--
 1 file changed, 352 insertions(+), 18 deletions(-)

diff --git a/drivers/soc/aspeed/aspeed-mctp.c b/drivers/soc/aspeed/aspeed-mctp.c
index 58d0857c4175..9104f18fa75b 100644
--- a/drivers/soc/aspeed/aspeed-mctp.c
+++ b/drivers/soc/aspeed/aspeed-mctp.c
@@ -319,25 +319,359 @@ struct aspeed_mctp_endpoint {

 struct kmem_cache *packet_cache;

-void data_dump(struct aspeed_mctp *priv, struct mctp_pcie_packet_data *data)
+#define SUCCESS                 0
+#define ERROR                   1
+#define ERROR_INVALID_DATA      2
+#define ERROR_INVALID_LENGTH    3
+#define ERROR_NOT_READY         4
+#define ERROR_UNSUPPORTED_CMD   5
+
+
+struct get_routing_table_entries {
+    u8 next_entry_handle;
+    u8 num_of_entries;
+    u8 size_eid_range;
+    u8 starting_eid;
+    u8 entry_type;
+    u8 Phy_transport_binding;
+    u8 Phy_media;
+    u8 Phy_address_size;
+    u16 Phy_address;
+};
+
+struct get_endpoint_id_data {
+    u8 endpoint_id;
+    u8 endpoint_type;
+    u8 endpoint_id_type;
+};
+
+struct get_mctp_version_support {
+    u8 num_of_entries;
+    u8 alpha;
+    u8 update_ver_num;
+    u8 minor_vr_num;
+    u8 major_ver_num;
+};
+
+struct get_message_type {
+    u8 num_of_msg_types;
+    u8 msg_list;
+};
+
+ struct get_uuid {
+    u32 time_low;
+    u16 time_mid;
+    u16 time_hi_and_version;
+    u8  clock_seq_hi_and_reserved;
+    u8  clock_seq_low;
+    u8  node[6];
+};
+
+ struct set_eid {
+    u8 eid_status;
+    u8 eid_set;
+    u8 eid_pool_size;
+};
+
+ struct alloc_eid {
+    u8 alloc_status;
+    u8 eid_pool_size;
+    u8 first_endpoint;
+};
+
+void print_allocate_eid(u32 *data)
 {
-	int i;
+    struct alloc_eid *aeid = (struct alloc_eid *)data;

-	dev_dbg(priv->dev, "Address %08x", (u32)data);
-	dev_dbg(priv->dev, "VDM header:");
-	for (i = 0; i < PCIE_VDM_HDR_SIZE_DW; i++) {
-		dev_dbg(priv->dev, "%02x %02x %02x %02x", data->hdr[i] & 0xff,
-		       (data->hdr[i] >> 8) & 0xff,
-		       (data->hdr[i] >> 16) & 0xff,
-		       (data->hdr[i] >> 24) & 0xff);
-	}
-	dev_dbg(priv->dev, "Data payload:");
-	for (i = 0; i < PCIE_VDM_DATA_SIZE_DW; i++) {
-		dev_dbg(priv->dev, "%02x %02x %02x %02x", data->payload[i] & 0xff,
-		       (data->payload[i] >> 8) & 0xff,
-		       (data->payload[i] >> 16) & 0xff,
-		       (data->payload[i] >> 24) & 0xff);
-	}
+    if ( (aeid->alloc_status && 0x03) == 0 )
+        printk("Allocation status     : Allocation was accepted\n");
+    else if ( (aeid->alloc_status && 0x03) == 1 )
+        printk("Allocation status     : Allocation was rejected\n");
+    else
+        printk("Allocation status     : Reserved\n");
+
+    printk("EID pool size         : %d\n", aeid->eid_pool_size);
+    printk("First Endpoint EID    : %d\n", aeid->first_endpoint);
+
+    return;
+}
+
+void print_set_eid(u32 *data)
+{
+    struct set_eid *seid = (struct set_eid *)data;
+
+    if ( (seid->eid_status && 0x03) == 0 )
+        printk("EID allocation status : Devic does not use an EID pool\n");
+    else if ( (seid->eid_status && 0x03) == 1 )
+        printk("EID allocation status : Endpoint requires EID pool allocation\n");
+    if ( (seid->eid_status && 0x03) == 2 )
+        printk("EID allocation status : Endpoint uses and EID pool\n");
+    else
+        printk("EID allocation status : Reserved\n");
+
+    printk("Endpoint EID set to   : %d\n", seid->eid_set);
+    printk("EID pool size         : %d\n", seid->eid_pool_size);
+
+    return;
+}
+
+void print_get_endpoint_uuid(u32 *data)
+{
+    struct get_uuid *uuid = (struct get_uuid *)data;
+    int i;
+
+    printk("UUID                  : %8.8x-%4.4x-%4.4x-%2.2x%2.2x-", uuid->time_low, uuid->time_mid,
+    uuid->time_hi_and_version, uuid->clock_seq_hi_and_reserved, uuid->clock_seq_low);
+    for (i = 0; i < 6; i++)
+        printk("%2.2x ", i, uuid->node[i]);
+    printk("\n");
+}
+
+void print_get_message_type(u32 *data)
+{
+    struct get_message_type *type_data = (struct get_message_type *)data;
+    struct get_message_type *ptr = (type_data);
+    int i;
+
+    printk("Num of msg entries    : %d\n", type_data->num_of_msg_types);
+    for ( i=0; i < type_data->num_of_msg_types; i++) {
+        printk("Message type          : %d\n", ptr->msg_list);
+        ptr++;
+    }
+
+    return;
+}
+
+void print_get_mctp_version_support(u32 *data)
+{
+    struct get_mctp_version_support *ver_data = (struct get_mctp_version_support *)data;
+    struct get_mctp_version_support *ptr = (ver_data);
+    int i;
+
+    printk("Num of ver entries    : %d\n", ver_data->num_of_entries);
+    for ( i=0; i < ver_data->num_of_entries; i++) {
+        printk("Major Version Num     : %d\n", ptr->major_ver_num);
+        printk("Minor Version Num     : %d\n", ptr->minor_vr_num);
+        printk("Update Version Num    : %d\n", ptr->update_ver_num);
+        printk("Alpha Version Num     : %d\n", ptr->alpha);
+        ptr = (ptr+4);
+    }
+
+    return;
+}
+
+void print_routing_table_entries(u32 *data)
+{
+    struct get_routing_table_entries *entries = (struct get_routing_table_entries *)data;
+
+    if ( entries->next_entry_handle == 0xFF)
+        printk("Next Entry Handle     : No more entries\n");
+    else
+        printk("Next Entry Handle     : 0x%02x\n", entries->next_entry_handle );
+
+    printk("Num of route entries  : %d\n", entries->num_of_entries);
+    printk("Size of EID range     : %d\n", entries->size_eid_range );
+    printk("Starting EID          : %d\n", entries->starting_eid );
+    printk("Port number           : %d\n", (entries->entry_type && 0x1F) );
+    if ( (entries->entry_type && 0x20) == 0x20)
+        printk("Dyname/Static         : Statically configured\n");
+    else
+        printk("Dynamic/Static        : Dynamically configured\n");
+
+    printk("Entry Type            : %d\n", ((entries->entry_type >> 6) && 0x03));
+    if (entries->Phy_transport_binding == 0x02 )
+        printk("Phy Transport Binding : MCTP over PCIe VDM\n");
+    else
+        printk("Phy Transport Binding : 0x%02X\n", entries->Phy_transport_binding);
+    if ( entries->Phy_media == 0x0A)
+        printk("Phy Media Type        : PCIe revision 2.1 compatible\n");
+    else
+        printk("Phy Media Type        : 0x%02X\n", entries->Phy_media);
+    printk("Phy Address size      : 0x%02X\n", entries->Phy_address_size);
+    printk("Phy Address           : 0x%02X%02X\n", (entries->Phy_address & 0xFF), ((entries->Phy_address >> 8) & 0xFF));
+
+    return;
+}
+
+void print_get_endpoint_eid(u32 *data)
+{
+    struct get_endpoint_id_data *eid_data = (struct get_endpoint_id_data *)data;
+    if ( eid_data->endpoint_id == 0)
+        printk("Endpoint ID           : EID not yet assigned\n");
+    else
+        printk("Endpoint ID           : %d\n", eid_data->endpoint_id);
+    if ( (eid_data->endpoint_type & 0x30) == 0 )
+        printk("Endpoint Type         : Simple Endpoint\n");
+    else if ( (eid_data->endpoint_type & 0x30) == 0x10 )
+        printk("Endpoint Type         : Bus owner/Bridge\n");
+    else
+        printk("Endpoint Type         : Reserved\n");
+
+    if ( (eid_data->endpoint_id_type & 0x03) == 0 )
+        printk("Endpoint ID Type      : Dynamic ID\n");
+    else
+        printk("Endpoint ID Type      : Static ID supported\n");
+
+    return;
+}
+
+void print_completion_code(u8 code)
+{
+    if (code == SUCCESS )
+        printk("Completion code       : SUCCESS\n");
+    else if (code == ERROR )
+        printk("Completion code       : ERROR\n");
+    else if (code == ERROR_INVALID_DATA )
+        printk("Completion code       : ERROR_INVALID_DATA\n");
+    else if (code == ERROR_INVALID_LENGTH )
+        printk("Completion code       : ERROR_INVALID_LENGTH\n");
+    else if (code == ERROR_NOT_READY )
+        printk("Completion code       : ERROR_NOT_READY\n");
+    else if (code == ERROR_UNSUPPORTED_CMD )
+        printk("Completion code       : ERROR_UNSUPPORTED_CMD\n");
+    else
+        printk("Completion code       : COMMAND_SPECIFIC\n");
+    return;
+}
+
+void data_dump(struct aspeed_mctp *priv, struct mctp_pcie_packet_data *data)
+{
+    int i;
+/*
+    if (((data->hdr[4] >> 8) & 0xE0) == 0x80)
+        printk("\nRequest ------->>");
+    else if (((data->hdr[4] >> 8) & 0xE0) == 0xC0)
+        printk("\nDatagram  <<------>> ");
+    else
+        printk("\nResponse <<-------- ");
+
+    printk("VDM header:");
+    for (i = 0; i < (PCIE_VDM_HDR_SIZE_DW +1); i++) {
+        printk("%02x %02x %02x %02x", data->hdr[i] & 0xff,
+               (data->hdr[i] >> 8) & 0xff,
+               (data->hdr[i] >> 16) & 0xff,
+               (data->hdr[i] >> 24) & 0xff);
+    }
+
+    printk("\nMCTP Data payload:");
+    for (i = 1; i < 5; i++) {
+        printk("%02x %02x %02x %02x", data->payload[i] & 0xff,
+           (data->payload[i] >> 8) & 0xff,
+           (data->payload[i] >> 16) & 0xff,
+           (data->payload[i] >> 24) & 0xff);
+    }
+
+    if ( (data->hdr[0] & 0x3) == 00 )
+        printk("Route Type : Route to RC\n");
+    else if ( (data->hdr[0] & 0x3) == 2 )
+        printk("Route Type : Route by ID\n");
+    else if ( (data->hdr[0] & 0x3) == 3 )
+        printk("Route Type : Broadcas from RC\n");
+    else
+        printk("Route Type : Unknown route\n");
+
+
+    printk("SBDF=0x%02X%02X, ", (data->hdr[1] & 0xFF), ((data->hdr[1]>>8)& 0xFF));
+    printk("TBDF=0x%04X, ", (data->hdr[2] & 0xFFFF));
+    printk("DEID=0x%02X, ", ((data->hdr[3] >> 8) & 0xFF));
+    printk("SEID=0x%02X, ", ((data->hdr[3] >> 16) & 0xFF));
+*/
+    switch ( ((data->hdr[4] >> 16) & 0xFF ) ) {
+        case 0x01:
+            printk("\nCommmand              : Set EID\n");
+            if (((data->hdr[4] >> 8) & 0xE0) == 0x0)
+            {
+                print_completion_code(((data->hdr[4] >> 24) & 0xFF ));
+                if ( ((data->hdr[4] >> 24) & 0xFF ) == 00 ) {
+                    printk("set EID               : %d", ((data->hdr[5] >> 8) & 0xFF));
+                    print_set_eid(&data->hdr[5]);
+                }
+            }
+            break;
+        case 0x02:
+            printk("\nCommmand              : Get EID\n");
+            if (((data->hdr[4] >> 8) & 0xE0) == 0){
+                print_completion_code(((data->hdr[4] >> 24) & 0xFF ));
+                if ( ((data->hdr[4] >> 24) & 0xFF ) == 00 )
+                    print_get_endpoint_eid(&data->hdr[5]);
+            }
+            break;
+        case 0x03:
+            printk("\nCommmand              : Get UUID\n");
+            if (((data->hdr[4] >> 8) & 0xE0) == 0){
+                print_completion_code(((data->hdr[4] >> 24) & 0xFF ));
+                if ( ((data->hdr[4] >> 24) & 0xFF ) == 00 )
+                    print_get_endpoint_uuid(&data->hdr[5]);
+            }
+            break;
+        case 0x04:
+            printk("\nCommmand              : Get MCTP Ver\n");
+            if (((data->hdr[4] >> 8) & 0xE0) == 0)
+            {
+                print_completion_code(((data->hdr[4] >> 24) & 0xFF ));
+                if ( ((data->hdr[4] >> 24) & 0xFF ) == 00 )
+                    print_get_mctp_version_support(&data->hdr[5]);
+            }
+            break;
+        case 0x05:
+            printk("\nCommmand              : Get Msg Type support\n");
+            if (((data->hdr[4] >> 8) & 0xE0) == 0) {
+                print_completion_code(((data->hdr[4] >> 24) & 0xFF ));
+                if ( ((data->hdr[4] >> 24) & 0xFF ) == 00 )
+                    print_get_message_type(&data->hdr[5]);
+            }
+            break;
+        case 0x06:
+            printk("\nCommmand              : Get VDM support capability\n");
+            if (((data->hdr[4] >> 8) & 0xE0) == 0)
+                print_completion_code(((data->hdr[4] >> 24) & 0xFF ));
+            break;
+        case 0x07:
+            printk("\nCommmand              : Resolve EID'\n");
+            if (((data->hdr[4] >> 8) & 0xE0) == 0)
+                print_completion_code(((data->hdr[4] >> 24) & 0xFF ));
+            break;
+        case 0x08:
+            printk("\nCommmand              : Allocate EID\n");
+            if (((data->hdr[4] >> 8) & 0xE0) == 0)
+                print_completion_code(((data->hdr[4] >> 24) & 0xFF ));
+            if ( ((data->hdr[4] >> 24) & 0xFF ) == SUCCESS) {
+                print_allocate_eid(&data->hdr[5]);
+                printk ("\nMCTP Discovery completed successfully....\n");
+            }
+            else
+                printk ("\nMCTP Discovery failed....\n");
+            break;
+        case 0x09:
+            printk("\nCommmand              : Routing info update\n");
+            if (((data->hdr[4] >> 8) & 0xE0) == 0)
+                print_completion_code(((data->hdr[4] >> 24) & 0xFF ));
+            break;
+        case 0x0A:
+            printk("\nCommmand              : Get Routing Table Entries\n");
+            if (((data->hdr[4] >> 8) & 0xE0) == 0) {
+                print_completion_code(((data->hdr[4] >> 24) & 0xFF ));
+                if ( ((data->hdr[4] >> 24) & 0xFF ) == 00 )
+                    print_routing_table_entries(&data->hdr[5]);
+            }
+            break;
+        case 0x0B:
+            printk("\nCommmand              : Prepare for EIP Discovery\n");
+            if (((data->hdr[4] >> 8) & 0xE0) == 0)
+                print_completion_code(((data->hdr[4] >> 24) & 0xFF ));
+            break;
+        case 0x0C:
+            printk("\nCommmand              : EndPoint Discovery\n");
+            if (((data->hdr[4] >> 8) & 0xE0) == 0)
+                print_completion_code(((data->hdr[4] >> 24) & 0xFF ));
+            break;
+        case 0x0D:
+            printk("\nCommmand              : Discovery Notify\n");
+            if (((data->hdr[4] >> 8) & 0xE0) == 0)
+                print_completion_code(((data->hdr[4] >> 24) & 0xFF ));
+            break;
+    }
+    return;
 }

 void *aspeed_mctp_packet_alloc(gfp_t flags)
@@ -490,7 +824,7 @@ static void aspeed_mctp_emit_tx_cmd(struct mctp_channel *tx,
 		sizeof(packet->data.hdr) / sizeof(u32);
 	u32 offset;

-	data_dump(priv, &packet->data);
+	//data_dump(priv, &packet->data);
 	aspeed_mctp_swap_pcie_vdm_hdr(&packet->data);

 	if (priv->match_data->vdm_hdr_direct_xfer) {
--
2.17.1

