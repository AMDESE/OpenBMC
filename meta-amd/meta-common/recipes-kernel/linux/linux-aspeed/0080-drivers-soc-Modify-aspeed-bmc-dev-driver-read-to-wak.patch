From 07624623ebc69de8d53cd121aa8c0efc76db6bd0 Mon Sep 17 00:00:00 2001
From: Mohsen Dolaty <mohsen.dolaty@amd.com>
Date: Thu, 21 Mar 2024 14:03:05 -0500
Subject: [PATCH 1/1] drivers:soc Modify aspeed bmc dev driver read

Modify ASPEED BMC Dev Driver Read functions for Q1 and Q2
to use Intr Enable bit before start reading the Ques
Disabled BMC To HOST Interrupt to avoid BIOS issues with unknown
interrupt

Signed-off-by: Mohsen Dolaty <mohsen.dolaty@amd.com>
---
 drivers/soc/aspeed/aspeed-bmc-dev.c | 42 +++++++++++++++++------------
 1 file changed, 25 insertions(+), 17 deletions(-)

diff --git a/drivers/soc/aspeed/aspeed-bmc-dev.c b/drivers/soc/aspeed/aspeed-bmc-dev.c
index 7b194f1bd762..69c1b44933bd 100644
--- a/drivers/soc/aspeed/aspeed-bmc-dev.c
+++ b/drivers/soc/aspeed/aspeed-bmc-dev.c
@@ -152,17 +152,22 @@ static ssize_t aspeed_host2bmc_queue1_rx(struct file *filp, struct kobject *kobj
 	u32 *data = (u32 *) buf;
 	u32 scu_id;
 	int ret;
-
+	u32 status;

 	ret = wait_event_interruptible(bmc_device->rx_wait0,
-		!(readl(bmc_device->reg_base + ASPEED_BMC_HOST2BMC_STS) & HOST2BMC_Q1_EMPTY));
+		((readl(bmc_device->reg_base + ASPEED_BMC_HOST2BMC_STS) & HOST2BMC_ENABLE_INTB) &&
+		!(readl(bmc_device->reg_base + ASPEED_BMC_HOST2BMC_STS) & HOST2BMC_Q1_EMPTY)));
+
+	status = readl(bmc_device->reg_base + ASPEED_BMC_HOST2BMC_STS);
+	dev_err(bmc_device->dev, "aspeed_host2bmc_queue1_rx(): status=0x%x\n", status);
+
 	if (ret)
 		return -EINTR;

 	data[0] = readl(bmc_device->reg_base + ASPEED_BMC_HOST2BMC_Q1);
 	regmap_read(bmc_device->scu, ASPEED_SCU04, &scu_id);
 	if (scu_id == AST2600A3_SCU04) {
-		writel(BMC2HOST_INT_STS_DOORBELL | BMC2HOST_ENABLE_INTB, bmc_device->reg_base + ASPEED_BMC_BMC2HOST_STS);
+		writel(HOST2BMC_Q1_FULL_UNMASK | HOST2BMC_ENABLE_INTB, bmc_device->reg_base + ASPEED_BMC_HOST2BMC_STS);
 	} else {
 		//A0 : BIT(12) A1 : BIT(15)
 		regmap_update_bits(bmc_device->scu, 0x560, BIT(15), BIT(15));
@@ -179,17 +184,22 @@ static ssize_t aspeed_host2bmc_queue2_rx(struct file *filp, struct kobject *kobj
 	u32 *data = (u32 *) buf;
 	u32 scu_id;
 	int ret;
-
+	u32 status;

 	ret = wait_event_interruptible(bmc_device->rx_wait1,
-		!(readl(bmc_device->reg_base + ASPEED_BMC_HOST2BMC_STS) & HOST2BMC_Q2_EMPTY));
+		((readl(bmc_device->reg_base + ASPEED_BMC_HOST2BMC_STS) & HOST2BMC_ENABLE_INTB) &&
+		!(readl(bmc_device->reg_base + ASPEED_BMC_HOST2BMC_STS) & HOST2BMC_Q2_EMPTY)));
+
+	status = readl(bmc_device->reg_base + ASPEED_BMC_HOST2BMC_STS);
+	dev_err(bmc_device->dev, "aspeed_host2bmc_queue2_rx(): status=0x%x\n", status);
+
 	if (ret)
 		return -EINTR;

 	data[0] = readl(bmc_device->reg_base + ASPEED_BMC_HOST2BMC_Q2);
 	regmap_read(bmc_device->scu, ASPEED_SCU04, &scu_id);
 	if (scu_id == AST2600A3_SCU04) {
-		writel(BMC2HOST_INT_STS_DOORBELL | BMC2HOST_ENABLE_INTB, bmc_device->reg_base + ASPEED_BMC_BMC2HOST_STS);
+		writel(HOST2BMC_Q2_FULL_UNMASK | HOST2BMC_ENABLE_INTB, bmc_device->reg_base + ASPEED_BMC_HOST2BMC_STS);
 	} else {
 		//A0 : BIT(12) A1 : BIT(15)
 		regmap_update_bits(bmc_device->scu, 0x560, BIT(15), BIT(15));
@@ -278,11 +288,19 @@ static irqreturn_t aspeed_bmc_dev_isr(int irq, void *dev_id)

 	u32 host2bmc_q_sts = readl(bmc_device->reg_base + ASPEED_BMC_HOST2BMC_STS);

+	dev_err(bmc_device->dev, "aspeed_bmc_dev_isr(): host2bmc_q_sts=0x%x\n", host2bmc_q_sts);
+
 	if (host2bmc_q_sts & HOST2BMC_INT_STS_DOORBELL)
 		writel(HOST2BMC_INT_STS_DOORBELL, bmc_device->reg_base + ASPEED_BMC_HOST2BMC_STS);

 	if (host2bmc_q_sts & HOST2BMC_ENABLE_INTB)
+	{
 		writel(HOST2BMC_ENABLE_INTB, bmc_device->reg_base + ASPEED_BMC_HOST2BMC_STS);
+		if (!(host2bmc_q_sts & HOST2BMC_Q1_EMPTY))
+			wake_up_interruptible(&bmc_device->rx_wait0);
+		if (!(host2bmc_q_sts & HOST2BMC_Q2_EMPTY))
+			wake_up_interruptible(&bmc_device->rx_wait1);
+	}

 	if (host2bmc_q_sts & HOST2BMC_Q1_FULL)
 	{
@@ -300,21 +318,11 @@ static irqreturn_t aspeed_bmc_dev_isr(int irq, void *dev_id)
 	   wake_up_interruptible(&bmc_device->tx_wait0);
 	}

-	if (!(readl(bmc_device->reg_base + ASPEED_BMC_HOST2BMC_STS) & HOST2BMC_Q1_EMPTY))
-	{
-	   wake_up_interruptible(&bmc_device->rx_wait0);
-	}
-
 	if (!(readl(bmc_device->reg_base + ASPEED_BMC_BMC2HOST_STS) & BMC2HOST_Q2_FULL))
 	{
 	   wake_up_interruptible(&bmc_device->tx_wait1);
 	}

-	if (!(readl(bmc_device->reg_base + ASPEED_BMC_HOST2BMC_STS) & HOST2BMC_Q2_EMPTY))
-	{
-	   wake_up_interruptible(&bmc_device->rx_wait1);
-	}
-
 	return IRQ_HANDLED;
 }

@@ -352,7 +360,7 @@ static void aspeed_bmc_device_init(struct aspeed_bmc_device *bmc_device)
 	writel(bmc_device->bmc_mem_phy, bmc_device->reg_base + ASPEED_BMC_MEM_BAR_REMAP);

 	//Setting BMC to Host Q register
-	writel(BMC2HOST_Q2_FULL_UNMASK | BMC2HOST_Q1_FULL_UNMASK | BMC2HOST_ENABLE_INTB, bmc_device->reg_base + ASPEED_BMC_BMC2HOST_STS);
+	writel(BMC2HOST_Q2_FULL_UNMASK | BMC2HOST_Q1_FULL_UNMASK , bmc_device->reg_base + ASPEED_BMC_BMC2HOST_STS);
 	writel(HOST2BMC_Q2_FULL_UNMASK | HOST2BMC_Q1_FULL_UNMASK | HOST2BMC_ENABLE_INTB, bmc_device->reg_base + ASPEED_BMC_HOST2BMC_STS);
 }

--
2.25.1
