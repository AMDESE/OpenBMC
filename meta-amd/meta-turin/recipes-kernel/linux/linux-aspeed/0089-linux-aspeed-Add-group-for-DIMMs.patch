From 7ea130a99848b923715ca500aaa0743244ed9d4f Mon Sep 17 00:00:00 2001
From: Mohsen Dolaty <mohsen.dolaty@amd.com>
Date: Mon, 16 May 2022 22:21:51 -0500
Subject: [PATCH 1/1] linux-aspeed: Add group for DIMMs

Add 24 DIMM devices as groups to 8 I3C Device
Address Tables
Access to APML devices is not changed

Signed-off-by: Mohsen Dolaty <mohsen.dolaty@amd.com>
---
 drivers/i3c/master/dw-i3c-master.c | 337 ++++++++++++++++++++++++-----
 1 file changed, 277 insertions(+), 60 deletions(-)

diff --git a/drivers/i3c/master/dw-i3c-master.c b/drivers/i3c/master/dw-i3c-master.c
index 2711d61a900d..77ce783d2fd4 100644
--- a/drivers/i3c/master/dw-i3c-master.c
+++ b/drivers/i3c/master/dw-i3c-master.c
@@ -199,22 +199,27 @@
 #define SLAVE_CONFIG			0xec

 #define DEV_ADDR_TABLE_LEGACY_I2C_DEV	BIT(31)
-#ifdef IBI_WIP
-#define DEV_ADDR_TABLE_IBI_WITH_DATA	BIT(12)
-#define DEV_ADDR_TABLE_IBI_PEC_EN	BIT(11)
-#define DEV_ADDR_TABLE_DYNAMIC_ADDR(x)                                         \
-	((((x) << 16) & GENMASK(23, 16)) | DEV_ADDR_TABLE_IBI_WITH_DATA)
-#else
+#define DEV_ADDR_TABLE_DEV_NACK_RETRY(x) (((x) << 29) & GENMASK(30, 29))
+#define DEV_ADDR_TABLE_IBI_ADDR_MASK    GENMASK(25, 24)
+#define IBI_ADDR_MASK_LAST_3BITS        ((1 << 24) & GENMASK(25, 24))
+#define IBI_ADDR_MASK_LAST_4BITS        ((2 << 24) & GENMASK(25, 24))
+#define DEV_ADDR_TABLE_MR_REJECT        BIT(14)
+#define DEV_ADDR_TABLE_SIR_REJECT       BIT(13)
+#define DEV_ADDR_TABLE_IBI_WITH_DATA    BIT(12)
+#define DEV_ADDR_TABLE_IBI_PEC_EN       BIT(11)
 #define DEV_ADDR_TABLE_DYNAMIC_ADDR(x)	(((x) << 16) & GENMASK(23, 16))
-#endif
 #define DEV_ADDR_TABLE_STATIC_ADDR(x)	((x) & GENMASK(6, 0))
 #define DEV_ADDR_TABLE_LOC(start, idx)	((start) + ((idx) << 2))
+#define GET_DYNAMIC_ADDR_FROM_DAT(x)    (((x)&GENMASK(22, 16)) >> 16)
+#define GET_DAT_FROM_POS(_master, _pos)                                        \
+        (readl(_master->regs + DEV_ADDR_TABLE_LOC(_master->datstartaddr, _pos)))

 #define DEV_ADDR_TABLE_LOC_OFFSET    0x280
 #define HW_RETRY_3_MASK              0x60000000
-#define NUM_OF_APML_DEVICES          3
+#define NUM_OF_I3C_DEVICES           8
 #define SDA_DLY_TIMING_OFFSET        0xD0
-#define SDA_TX_HOLD                  0x00030000
+#define SDA_TX_HOLD_APML             0x00030000
+#define SDA_TX_HOLD_DIMM             0x00020000
 #define SDA_TX_MASK                  0xFFF8FFFF

 #define MAX_DEVS 32
@@ -233,6 +238,14 @@

 #define XFER_TIMEOUT (msecs_to_jiffies(1000))

+#define MAX_GROUPS                      (1 << 4)
+#define MAX_DEVS_IN_GROUP               (1 << 3)
+#define ALL_DEVS_IN_GROUP_ARE_FREE      ((1 << MAX_DEVS_IN_GROUP) - 1)
+#define ADDR_GRP_MASK                   GENMASK(6, 3)
+#define ADDR_GRP(x)                     (((x) & ADDR_GRP_MASK) >> 3)
+#define ADDR_HID_MASK                   GENMASK(2, 0)
+#define ADDR_HID(x)                     ((x) & ADDR_HID_MASK)
+
 struct dw_i3c_master_caps {
 	u8 cmdfifodepth;
 	u8 datafifodepth;
@@ -256,12 +269,23 @@ struct dw_i3c_xfer {
 	struct dw_i3c_cmd cmds[0];
 };

+struct dw_i3c_dev_group {
+	u32 dat[8];
+	u32 free_pos;
+	int hw_index;
+	struct {
+		u32 set;
+		u32 clr;
+	} mask;
+};
+
 struct dw_i3c_master {
 	struct device *dev;
 	struct i3c_master_controller base;
 	u16 maxdevs;
 	u16 datstartaddr;
 	u32 free_pos;
+	struct dw_i3c_dev_group dev_group[MAX_GROUPS];
 	struct {
 		struct list_head list;
 		struct dw_i3c_xfer *cur;
@@ -364,6 +388,96 @@ static int dw_i3c_master_get_free_pos(struct dw_i3c_master *master)

 	return ffs(master->free_pos) - 1;
 }
+static void dw_i3c_master_init_group_dat(struct dw_i3c_master *master)
+{
+	struct dw_i3c_dev_group *dev_grp;
+	int i, j;
+	u32 def_set, def_clr;
+
+	def_clr = DEV_ADDR_TABLE_IBI_ADDR_MASK;
+
+	/* For now don't support Hot-Join */
+	def_set = DEV_ADDR_TABLE_MR_REJECT | DEV_ADDR_TABLE_SIR_REJECT | IBI_ADDR_MASK_LAST_3BITS;
+
+	for (i = 0; i < MAX_GROUPS; i++) {
+		dev_grp = &master->dev_group[i];
+		dev_grp->hw_index = -1;
+		dev_grp->free_pos = ALL_DEVS_IN_GROUP_ARE_FREE;
+		dev_grp->mask.set = def_set;
+		dev_grp->mask.clr = def_clr;
+		for (j = 0; j < MAX_DEVS_IN_GROUP; j++)
+			dev_grp->dat[j] = 0;
+	}
+
+	for (i = 0; i < master->maxdevs; i++)
+		writel(def_set, master->regs + DEV_ADDR_TABLE_LOC(master->datstartaddr, i));
+}
+
+static int dw_i3c_master_set_group_dat(struct dw_i3c_master *master, u8 addr, u32 val)
+{
+	struct dw_i3c_dev_group *dev_grp = &master->dev_group[ADDR_GRP(addr)];
+	u8 idx = ADDR_HID(addr);
+
+	dev_grp->dat[idx] = val;
+
+	if (val) {
+		dev_grp->free_pos &= ~BIT(idx);
+		/*
+		 * reserve the hw dat resource for the first member of the
+		 * group. all the members in the group share the same hw dat.
+		 */
+		if (dev_grp->hw_index == -1) {
+			dev_grp->hw_index = dw_i3c_master_get_free_pos(master);
+			if (dev_grp->hw_index < 0)
+				goto out;
+
+			master->free_pos &= ~BIT(dev_grp->hw_index);
+			writel(val, master->regs + DEV_ADDR_TABLE_LOC(
+							master->datstartaddr,
+							dev_grp->hw_index));
+		}
+	} else {
+		dev_grp->free_pos |= BIT(idx);
+
+		/*
+		 * release the hw dat resource if all the members in the group
+		 * are free.
+		 */
+		if (dev_grp->free_pos == ALL_DEVS_IN_GROUP_ARE_FREE) {
+			writel(0, master->regs + DEV_ADDR_TABLE_LOC(
+							master->datstartaddr,
+							dev_grp->hw_index));
+			master->free_pos |= BIT(dev_grp->hw_index);
+			dev_grp->hw_index = -1;
+		}
+	}
+out:
+	return dev_grp->hw_index;
+}
+
+static int dw_i3c_master_get_group_hw_index(struct dw_i3c_master *master,
+                                            u8 addr)
+{
+	struct dw_i3c_dev_group *dev_grp = &master->dev_group[ADDR_GRP(addr)];
+
+	return dev_grp->hw_index;
+}
+
+static int dw_i3c_master_sync_hw_dat(struct dw_i3c_master *master, u8 addr)
+{
+	struct dw_i3c_dev_group *dev_grp = &master->dev_group[ADDR_GRP(addr)];
+	u32 dat = dev_grp->dat[ADDR_HID(addr)];
+	int hw_index = dev_grp->hw_index;
+
+	if (!dat || hw_index < 0)
+		return -1;
+
+	dat &= ~dev_grp->mask.clr;
+	dat |= dev_grp->mask.set;
+	writel(dat, master->regs +
+		DEV_ADDR_TABLE_LOC(master->datstartaddr, hw_index));
+	return hw_index;
+}

 static void dw_i3c_master_wr_tx_fifo(struct dw_i3c_master *master,
 				     const u8 *bytes, int nbytes)
@@ -783,7 +897,10 @@ static int dw_i3c_ccc_set(struct dw_i3c_master *master,
 	int ret, pos = 0;

 	if (ccc->id & I3C_CCC_DIRECT) {
-		pos = dw_i3c_master_get_addr_pos(master, ccc->dests[0].addr);
+		if(master->base.set_dasa) // APML
+			pos = dw_i3c_master_get_addr_pos(master, ccc->dests[0].addr);
+		else // DIMM
+			pos = dw_i3c_master_sync_hw_dat(master, ccc->dests[0].addr);
 		if (pos < 0)
 			return pos;
 	}
@@ -827,7 +944,10 @@ static int dw_i3c_ccc_get(struct dw_i3c_master *master, struct i3c_ccc_cmd *ccc)
 	struct dw_i3c_cmd *cmd;
 	int ret, pos;

-	pos = dw_i3c_master_get_addr_pos(master, ccc->dests[0].addr);
+	if(master->base.set_dasa) // APML
+		pos = dw_i3c_master_get_addr_pos(master, ccc->dests[0].addr);
+	else // DIMM
+		pos = dw_i3c_master_sync_hw_dat(master, ccc->dests[0].addr);
 	if (pos < 0)
 		return pos;

@@ -902,9 +1022,10 @@ static int dw_i3c_master_daa(struct i3c_master_controller *m)
 	struct dw_i3c_cmd *cmd;
 	u32 olddevs, newdevs;
 	u8 p, last_addr = 0;
-	int ret, pos;
+	int ret, pos, ndevs;

 	olddevs = ~(master->free_pos);
+	ndevs = 0;

 	/* Prepare DAT before launching DAA. */
 	for (pos = 0; pos < master->maxdevs; pos++) {
@@ -913,7 +1034,9 @@ static int dw_i3c_master_daa(struct i3c_master_controller *m)

 		ret = i3c_master_get_free_addr(m, last_addr + 1);
 		if (ret < 0)
-			return -ENOSPC;
+			break;
+
+		ndevs++;

 		master->addrs[pos] = ret;
 		p = even_parity(ret);
@@ -925,6 +1048,9 @@ static int dw_i3c_master_daa(struct i3c_master_controller *m)
 		       DEV_ADDR_TABLE_LOC(master->datstartaddr, pos));
 	}

+	if (!ndevs)
+		return -ENOSPC;
+
 	xfer = dw_i3c_master_alloc_xfer(master, 1);
 	if (!xfer)
 		return -ENOMEM;
@@ -943,24 +1069,38 @@ static int dw_i3c_master_daa(struct i3c_master_controller *m)
 	if (!wait_for_completion_timeout(&xfer->comp, XFER_TIMEOUT))
 		dw_i3c_master_dequeue_xfer(master, xfer);

-	newdevs = GENMASK(master->maxdevs - cmd->rx_len - 1, 0);
-	newdevs &= ~olddevs;
-
+	if(m->set_dasa) { // APML
+		newdevs = GENMASK(master->maxdevs - cmd->rx_len - 1, 0);
+		newdevs &= ~olddevs;
+	}
+	else  // DIMM
+		newdevs = GENMASK(ndevs - cmd->rx_len - 1, 0) << pos;
 	for (pos = 0; pos < master->maxdevs; pos++) {
-		if (newdevs & BIT(pos))
-			i3c_master_add_i3c_dev_locked(m, master->addrs[pos]);
+		if (newdevs & BIT(pos)) {
+			if(m->set_dasa)  // APML
+				i3c_master_add_i3c_dev_locked(m, master->addrs[pos]);
+			else {  // DIMM
+				u32 dat = GET_DAT_FROM_POS(master, pos);
+				u32 addr = GET_DYNAMIC_ADDR_FROM_DAT(dat);
+
+				dw_i3c_master_set_group_dat(master, addr, dat);
+				i3c_master_add_i3c_dev_locked(m, addr);
+			}
+		}
+
+		/* cleanup the free HW DATs */
+		if ((master->free_pos & BIT(pos)) &&
+		   (!(m->set_dasa)))
+			writel(0, master->regs +
+				DEV_ADDR_TABLE_LOC( master->datstartaddr, pos));
 	}

 	dw_i3c_master_free_xfer(xfer);
-#ifdef IBI_WIP
-	ret = i3c_master_enec_locked(m, I3C_BROADCAST_ADDR,
-				     I3C_CCC_EVENT_SIR);
-#else
-	i3c_master_disec_locked(m, I3C_BROADCAST_ADDR,
-				I3C_CCC_EVENT_HJ |
-				I3C_CCC_EVENT_MR |
-				I3C_CCC_EVENT_SIR);
-#endif
+	if(m->set_dasa)
+		i3c_master_disec_locked(m, I3C_BROADCAST_ADDR,
+					I3C_CCC_EVENT_HJ |
+					I3C_CCC_EVENT_MR |
+					I3C_CCC_EVENT_SIR);

 	return 0;
 }
@@ -1085,6 +1225,9 @@ static int dw_i3c_master_priv_xfers(struct i3c_dev_desc *dev,
 	if (!xfer)
 		return -ENOMEM;

+	if(!(m->set_dasa))  // DIMM
+		data->index = dw_i3c_master_sync_hw_dat(master, dev->info.dyn_addr);
+
 	for (i = 0; i < i3c_nxfers; i++) {
 		struct dw_i3c_cmd *cmd = &xfer->cmds[i];

@@ -1121,6 +1264,15 @@ static int dw_i3c_master_priv_xfers(struct i3c_dev_desc *dev,
 	if (!wait_for_completion_timeout(&xfer->comp, XFER_TIMEOUT))
 		dw_i3c_master_dequeue_xfer(master, xfer);

+	if(!(m->set_dasa))  {  // DIMM
+		for (i = 0; i < i3c_nxfers; i++) {
+			struct dw_i3c_cmd *cmd = &xfer->cmds[i];
+
+			if (i3c_xfers[i].rnw)
+				i3c_xfers[i].len = cmd->rx_len;
+		}
+	}
+
 	ret = xfer->ret;
 	dw_i3c_master_free_xfer(xfer);

@@ -1134,23 +1286,49 @@ static int dw_i3c_master_reattach_i3c_dev(struct i3c_dev_desc *dev,
 	struct i3c_master_controller *m = i3c_dev_get_master(dev);
 	struct dw_i3c_master *master = to_dw_i3c_master(m);

-	writel(DEV_ADDR_TABLE_DYNAMIC_ADDR(dev->info.dyn_addr),
-	       master->regs +
-	       DEV_ADDR_TABLE_LOC(master->datstartaddr, data->index));
+	if(m->set_dasa)  // APML
+		writel(DEV_ADDR_TABLE_DYNAMIC_ADDR(dev->info.dyn_addr),master->regs +
+			DEV_ADDR_TABLE_LOC(master->datstartaddr, data->index));
+	else  // DIMM
+		dw_i3c_master_set_group_dat(
+			master, dev->info.dyn_addr,
+			DEV_ADDR_TABLE_DYNAMIC_ADDR(dev->info.dyn_addr));

 	master->addrs[data->index] = dev->info.dyn_addr;

 	return 0;
 }

+static int scl_rate_to_speed_index(unsigned long scl_rate)
+{
+	switch (scl_rate) {
+	case I3C_BUS_SDR1_SCL_RATE:
+		return 1;
+	case I3C_BUS_SDR2_SCL_RATE:
+		return 2;
+	case I3C_BUS_SDR3_SCL_RATE:
+		return 3;
+	case I3C_BUS_SDR4_SCL_RATE:
+		return 4;
+	case I3C_BUS_TYP_I3C_SCL_RATE:
+	default:
+		return 0;
+	}
+}
+
 static int dw_i3c_master_attach_i3c_dev(struct i3c_dev_desc *dev)
 {
 	struct i3c_master_controller *m = i3c_dev_get_master(dev);
 	struct dw_i3c_master *master = to_dw_i3c_master(m);
 	struct dw_i3c_i2c_dev_data *data;
 	int pos;
+	u8 addr = dev->info.dyn_addr ? : dev->info.static_addr;

-	pos = dw_i3c_master_get_free_pos(master);
+	if (m->set_dasa)  // APML
+		pos = dw_i3c_master_get_free_pos(master);
+	else  // DIMM
+		pos = dw_i3c_master_set_group_dat(master, addr,
+                                          DEV_ADDR_TABLE_DYNAMIC_ADDR(addr));
 	if (pos < 0)
 		return pos;

@@ -1158,15 +1336,26 @@ static int dw_i3c_master_attach_i3c_dev(struct i3c_dev_desc *dev)
 	if (!data)
 		return -ENOMEM;

-	data->index = pos;
-	master->addrs[pos] = dev->info.dyn_addr ? : dev->info.static_addr;
-	master->free_pos &= ~BIT(pos);
-	i3c_dev_set_master_data(dev, data);
-
-	writel(DEV_ADDR_TABLE_DYNAMIC_ADDR(master->addrs[pos]),
-	       master->regs +
-	       DEV_ADDR_TABLE_LOC(master->datstartaddr, data->index));
+	if (m->set_dasa) {  // APML
+		data->index = pos;
+		master->addrs[pos] = dev->info.dyn_addr ? : dev->info.static_addr;
+		master->free_pos &= ~BIT(pos);
+		i3c_dev_set_master_data(dev, data);

+		writel(DEV_ADDR_TABLE_DYNAMIC_ADDR(master->addrs[pos]),
+			master->regs +
+			DEV_ADDR_TABLE_LOC(master->datstartaddr, data->index));
+	}
+	else { // DIMM
+		data->index = dw_i3c_master_get_group_hw_index(master, addr);
+		master->addrs[pos] = addr;
+		i3c_dev_set_master_data(dev, data);
+
+		if (master->base.jdec_spd) {
+			dev->info.max_write_ds = dev->info.max_read_ds =
+				scl_rate_to_speed_index(m->bus.scl_rate.i3c);
+		}
+	}
 	return 0;
 }

@@ -1176,13 +1365,16 @@ static void dw_i3c_master_detach_i3c_dev(struct i3c_dev_desc *dev)
 	struct i3c_master_controller *m = i3c_dev_get_master(dev);
 	struct dw_i3c_master *master = to_dw_i3c_master(m);

-	writel(0,
-	       master->regs +
-	       DEV_ADDR_TABLE_LOC(master->datstartaddr, data->index));
+	if (m->set_dasa)  // APML
+		writel(0, master->regs +
+			DEV_ADDR_TABLE_LOC(master->datstartaddr, data->index));
+	else  // DIMM
+		dw_i3c_master_set_group_dat(master, dev->info.dyn_addr, 0);

 	i3c_dev_set_master_data(dev, NULL);
 	master->addrs[data->index] = 0;
-	master->free_pos |= BIT(data->index);
+	if (m->set_dasa)  // APML
+		master->free_pos |= BIT(data->index);
 	kfree(data);
 }

@@ -1195,7 +1387,7 @@ static int dw_i3c_master_i2c_xfers(struct i2c_dev_desc *dev,
 	struct dw_i3c_master *master = to_dw_i3c_master(m);
 	unsigned int nrxwords = 0, ntxwords = 0;
 	struct dw_i3c_xfer *xfer;
-	int i, ret = 0;
+	int speed, i, ret = 0;

 	if (!i2c_nxfers)
 		return 0;
@@ -1218,6 +1410,9 @@ static int dw_i3c_master_i2c_xfers(struct i2c_dev_desc *dev,
 	if (!xfer)
 		return -ENOMEM;

+	data->index = dw_i3c_master_sync_hw_dat(master, dev->addr);
+	speed = (master->base.bus.scl_rate.i2c == I3C_BUS_I2C_FM_PLUS_SCL_RATE) ? 1 : 0;
+
 	for (i = 0; i < i2c_nxfers; i++) {
 		struct dw_i3c_cmd *cmd = &xfer->cmds[i];

@@ -1226,6 +1421,7 @@ static int dw_i3c_master_i2c_xfers(struct i2c_dev_desc *dev,

 		cmd->cmd_lo = COMMAND_PORT_TID(i) |
 			      COMMAND_PORT_DEV_INDEX(data->index) |
+			      COMMAND_PORT_SPEED(speed) |
 			      COMMAND_PORT_ROC;

 		if (i2c_xfers[i].flags & I2C_M_RD) {
@@ -1258,7 +1454,13 @@ static int dw_i3c_master_attach_i2c_dev(struct i2c_dev_desc *dev)
 	struct dw_i3c_i2c_dev_data *data;
 	int pos;

-	pos = dw_i3c_master_get_free_pos(master);
+	if (m->set_dasa)  // APML
+		pos = dw_i3c_master_get_free_pos(master);
+	else
+		pos = dw_i3c_master_set_group_dat(
+			master, dev->addr,
+			DEV_ADDR_TABLE_LEGACY_I2C_DEV |
+			DEV_ADDR_TABLE_STATIC_ADDR(dev->addr));
 	if (pos < 0)
 		return pos;

@@ -1266,15 +1468,21 @@ static int dw_i3c_master_attach_i2c_dev(struct i2c_dev_desc *dev)
 	if (!data)
 		return -ENOMEM;

-	data->index = pos;
-	master->addrs[pos] = dev->addr;
-	master->free_pos &= ~BIT(pos);
-	i2c_dev_set_master_data(dev, data);
-
-	writel(DEV_ADDR_TABLE_LEGACY_I2C_DEV |
-	       DEV_ADDR_TABLE_STATIC_ADDR(dev->addr),
-	       master->regs +
-	       DEV_ADDR_TABLE_LOC(master->datstartaddr, data->index));
+	if (m->set_dasa) {  // APML
+		data->index = pos;
+		master->addrs[pos] = dev->addr;
+		master->free_pos &= ~BIT(pos);
+		i2c_dev_set_master_data(dev, data);
+		writel(DEV_ADDR_TABLE_LEGACY_I2C_DEV |
+			DEV_ADDR_TABLE_STATIC_ADDR(dev->addr),
+			master->regs +
+			DEV_ADDR_TABLE_LOC(master->datstartaddr, data->index));
+	}
+	else  {  // DIMM
+		data->index = dw_i3c_master_get_group_hw_index(master, dev->addr);
+		master->addrs[data->index] = dev->addr;
+		i2c_dev_set_master_data(dev, data);
+	}

 	return 0;
 }
@@ -1285,13 +1493,17 @@ static void dw_i3c_master_detach_i2c_dev(struct i2c_dev_desc *dev)
 	struct i3c_master_controller *m = i2c_dev_get_master(dev);
 	struct dw_i3c_master *master = to_dw_i3c_master(m);

-	writel(0,
-	       master->regs +
-	       DEV_ADDR_TABLE_LOC(master->datstartaddr, data->index));
+	if (m->set_dasa)  // APML
+		writel(0,
+			master->regs +
+			DEV_ADDR_TABLE_LOC(master->datstartaddr, data->index));
+	else  // DIMM
+		dw_i3c_master_set_group_dat(master, dev->addr, 0);

 	i2c_dev_set_master_data(dev, NULL);
 	master->addrs[data->index] = 0;
-	master->free_pos |= BIT(data->index);
+	if (m->set_dasa)  // APML
+		master->free_pos |= BIT(data->index);
 	kfree(data);
 }

@@ -1401,6 +1613,8 @@ static int dw_i3c_probe(struct platform_device *pdev)
 	//master->maxdevs = ret >> 16;
 	master->maxdevs = MAX_DEVS;
 	master->free_pos = GENMASK(master->maxdevs - 1, 0);
+	if(!(master->base.set_dasa))  // DIMM
+		dw_i3c_master_init_group_dat(master);
 #ifdef CCC_WORKAROUND
 	master->free_pos &= ~BIT(master->maxdevs - 1);
 	ret = (even_parity(I3C_BROADCAST_ADDR) << 7) | I3C_BROADCAST_ADDR;
@@ -1419,7 +1633,7 @@ static int dw_i3c_probe(struct platform_device *pdev)
 	pr_err( "dw_i3c_probe: Done " "Register dev %s, bus %d\n",
                 dev_name(&pdev->dev), master->base.bus.id );
 	// set HW Retry to 3 times for NAK
-	for(i=0; i<NUM_OF_APML_DEVICES; i++) {
+	for(i=0; i<NUM_OF_I3C_DEVICES; i++) {
 		i3c_reg = DEV_ADDR_TABLE_LOC_OFFSET + i*4;
 		i3c_data = readl(master->regs + i3c_reg);
 		i3c_data = i3c_data | HW_RETRY_3_MASK ;
@@ -1429,7 +1643,10 @@ static int dw_i3c_probe(struct platform_device *pdev)
 	i3c_reg = SDA_DLY_TIMING_OFFSET;
 	i3c_data = readl(master->regs + i3c_reg);
 	i3c_data = i3c_data & SDA_TX_MASK;
-	i3c_data = i3c_data | SDA_TX_HOLD;
+	if(master->base.set_dasa)  // APML
+		i3c_data = i3c_data | SDA_TX_HOLD_APML;
+	else  // DIMM
+		i3c_data = i3c_data | SDA_TX_HOLD_DIMM;
 	writel(i3c_data, master->regs + i3c_reg);

 	return 0;
--
2.25.1
