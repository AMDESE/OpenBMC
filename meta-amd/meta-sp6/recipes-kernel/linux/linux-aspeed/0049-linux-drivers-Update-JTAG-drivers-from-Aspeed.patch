From 3095419b56cc80ce9dcddfe557c993e937a9fe5d Mon Sep 17 00:00:00 2001
From: Supreeth Venkatesh <supreeth.venkatesh@amd.com>
Date: Mon, 25 Oct 2021 22:21:39 -0500
Subject: [PATCH 1/1] linux/drivers: Update JTAG drivers from Aspeed
Content-Type: text/plain; charset="us-ascii"
Content-Transfer-Encoding: 7bit

Updates JTAG drivers from Aspeed which has fixes on top of OpenBMC JTAG
driver.

Signed-off-by: Billy Tsai <billy_tsai@aspeedtech.com>
Signed-off-by: Supreeth Venkatesh <supreeth.venkatesh@amd.com>
---
 drivers/Makefile                    |   2 +-
 drivers/jtag/Kconfig                |  14 +
 drivers/jtag/Makefile               |   1 +
 drivers/jtag/jtag-aspeed-internal.c | 979 ++++++++++++++++++++++++++++
 drivers/jtag/jtag-aspeed.c          | 522 ++++++++-------
 drivers/jtag/jtag.c                 |   1 +
 include/uapi/linux/jtag.h           | 154 ++++-
 7 files changed, 1424 insertions(+), 249 deletions(-)
 create mode 100644 drivers/jtag/jtag-aspeed-internal.c

diff --git a/drivers/Makefile b/drivers/Makefile
index c2a631ec7583..e367e5484199 100644
--- a/drivers/Makefile
+++ b/drivers/Makefile
@@ -189,4 +189,4 @@ obj-$(CONFIG_GNSS)		+= gnss/
 obj-$(CONFIG_INTERCONNECT)	+= interconnect/
 obj-$(CONFIG_COUNTER)		+= counter/
 obj-$(CONFIG_MOST)		+= most/
-obj-$(CONFIG_JTAG_ASPEED)	+= jtag/
+obj-$(CONFIG_JTAG)	+= jtag/
diff --git a/drivers/jtag/Kconfig b/drivers/jtag/Kconfig
index 0cc163f9ad44..0c22c6a7e85e 100644
--- a/drivers/jtag/Kconfig
+++ b/drivers/jtag/Kconfig
@@ -29,3 +29,17 @@ menuconfig JTAG_ASPEED

 	  To compile this driver as a module, choose M here: the module will
 	  be called jtag-aspeed.
+
+menuconfig JTAG_ASPEED_INTERNAL
+	tristate "Aspeed SoC JTAG controller support internal"
+	depends on JTAG && HAS_IOMEM
+	depends on ARCH_ASPEED || COMPILE_TEST
+	help
+	  This provides a support for Aspeed JTAG device, equipped on
+	  Aspeed SoC 24xx and 25xx families. Drivers allows programming
+	  of hardware devices, connected to SoC through the JTAG interface.
+
+	  If you want this support, you should say Y here.
+
+	  To compile this driver as a module, choose M here: the module will
+	  be called jtag-aspeed.
diff --git a/drivers/jtag/Makefile b/drivers/jtag/Makefile
index 04a855e2df28..506886e7b7a8 100644
--- a/drivers/jtag/Makefile
+++ b/drivers/jtag/Makefile
@@ -1,2 +1,3 @@
 obj-$(CONFIG_JTAG)		+= jtag.o
 obj-$(CONFIG_JTAG_ASPEED)	+= jtag-aspeed.o
+obj-$(CONFIG_JTAG_ASPEED_INTERNAL) += jtag-aspeed-internal.o
diff --git a/drivers/jtag/jtag-aspeed-internal.c b/drivers/jtag/jtag-aspeed-internal.c
new file mode 100644
index 000000000000..edbc1849e159
--- /dev/null
+++ b/drivers/jtag/jtag-aspeed-internal.c
@@ -0,0 +1,979 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * JTAG driver for the Aspeed SoC
+ *
+ * Copyright (C) 2021 ASPEED Technology Inc.
+ * Ryan Chen <ryan_chen@aspeedtech.com>
+ *
+ */
+#include <linux/poll.h>
+#include <linux/sysfs.h>
+#include <linux/clk.h>
+#include <linux/fs.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/miscdevice.h>
+#include <linux/slab.h>
+#include <linux/sched.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/jtag.h>
+#include <linux/platform_device.h>
+#include <linux/reset.h>
+#include <linux/io.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/uaccess.h>
+#include <uapi/linux/jtag.h>
+/******************************************************************************/
+#define ASPEED_JTAG_DATA		0x00
+#define ASPEED_JTAG_INST		0x04
+#define ASPEED_JTAG_CTRL		0x08
+#define ASPEED_JTAG_ISR			0x0C
+#define ASPEED_JTAG_SW			0x10
+#define ASPEED_JTAG_TCK			0x14
+#define ASPEED_JTAG_IDLE		0x18
+
+/* ASPEED_JTAG_CTRL - 0x08 : Engine Control */
+#define JTAG_ENG_EN			BIT(31)
+#define JTAG_ENG_OUT_EN			BIT(30)
+#define JTAG_FORCE_TMS			BIT(29)
+
+#define JTAG_IR_UPDATE			BIT(26)		//AST2500 only
+
+#define JTAG_G6_RESET_FIFO		BIT(21)		//AST2600 only
+#define JTAG_G6_CTRL_MODE		BIT(20)		//AST2600 only
+#define JTAG_G6_XFER_LEN_MASK		(0x3ff << 8)	//AST2600 only
+#define JTAG_G6_SET_XFER_LEN(x)		(x << 8)
+#define JTAG_G6_MSB_FIRST		BIT(6)		//AST2600 only
+#define JTAG_G6_TERMINATE_XFER		BIT(5)		//AST2600 only
+#define JTAG_G6_LAST_XFER		BIT(4)		//AST2600 only
+#define JTAG_G6_INST_EN			BIT(1)
+
+#define JTAG_INST_LEN_MASK		(0x3f << 20)
+#define JTAG_SET_INST_LEN(x)		(x << 20)
+#define JTAG_SET_INST_MSB		BIT(19)
+#define JTAG_TERMINATE_INST		BIT(18)
+#define JTAG_LAST_INST			BIT(17)
+#define JTAG_INST_EN			BIT(16)
+#define JTAG_DATA_LEN_MASK		(0x3f << 4)
+
+#define JTAG_DR_UPDATE			BIT(10)		//AST2500 only
+#define JTAG_DATA_LEN(x)		(x << 4)
+#define JTAG_MSB_FIRST			BIT(3)
+#define JTAG_TERMINATE_DATA		BIT(2)
+#define JTAG_LAST_DATA			BIT(1)
+#define JTAG_DATA_EN			BIT(0)
+
+/* ASPEED_JTAG_ISR	- 0x0C : INterrupt status and enable */
+#define JTAG_INST_PAUSE			BIT(19)
+#define JTAG_INST_COMPLETE		BIT(18)
+#define JTAG_DATA_PAUSE			BIT(17)
+#define JTAG_DATA_COMPLETE		BIT(16)
+
+#define JTAG_INST_PAUSE_EN		BIT(3)
+#define JTAG_INST_COMPLETE_EN		BIT(2)
+#define JTAG_DATA_PAUSE_EN		BIT(1)
+#define JTAG_DATA_COMPLETE_EN		BIT(0)
+
+/* ASPEED_JTAG_SW	- 0x10 : Software Mode and Status */
+#define JTAG_SW_MODE_EN			BIT(19)
+#define JTAG_SW_MODE_TCK		BIT(18)
+#define JTAG_SW_MODE_TMS		BIT(17)
+#define JTAG_SW_MODE_TDIO		BIT(16)
+//
+#define JTAG_STS_INST_PAUSE		BIT(2)
+#define JTAG_STS_DATA_PAUSE		BIT(1)
+#define JTAG_STS_ENG_IDLE		(0x1)
+
+/* ASPEED_JTAG_TCK	- 0x14 : TCK Control */
+#define JTAG_TCK_INVERSE		BIT(31)
+#define JTAG_TCK_DIVISOR_MASK		(0x7ff)
+#define JTAG_GET_TCK_DIVISOR(x)		(x & 0x7ff)
+
+/*  ASPEED_JTAG_IDLE - 0x18 : Ctroller set for go to IDLE */
+#define JTAG_CTRL_TRSTn_HIGH		BIT(31)
+#define JTAG_GO_IDLE			BIT(0)
+
+#define TCK_FREQ			1000000
+/******************************************************************************/
+#define ASPEED_JTAG_DEBUG
+
+#ifdef ASPEED_JTAG_DEBUG
+#define JTAG_DBUG(fmt, args...)                                                \
+	pr_debug("%s() " fmt, __func__, ##args)
+#else
+#define JTAG_DBUG(fmt, args...)
+#endif
+
+struct aspeed_jtag_config {
+	u8	jtag_version;
+	u32	jtag_buff_len;
+};
+
+struct aspeed_jtag_info {
+	void __iomem			*reg_base;
+	struct device			*dev;
+	struct aspeed_jtag_config	*config;
+	enum jtag_tapstate		sts;
+	int				irq;
+	struct reset_control		*reset;
+	struct clk			*clk;
+	u32				clkin;
+	u32				tck_period;
+	u32				sw_delay;
+	u32				flag;
+	wait_queue_head_t		jtag_wq;
+	u32				mode;
+};
+/******************************************************************************/
+static inline u32
+aspeed_jtag_read(struct aspeed_jtag_info *aspeed_jtag, u32 reg)
+{
+	int val;
+
+	val = readl(aspeed_jtag->reg_base + reg);
+	JTAG_DBUG("reg = 0x%08x, val = 0x%08x\n", reg, val);
+	return val;
+}
+
+static inline void
+aspeed_jtag_write(struct aspeed_jtag_info *aspeed_jtag, u32 val, u32 reg)
+{
+	JTAG_DBUG("reg = 0x%08x, val = 0x%08x\n", reg, val);
+	writel(val, aspeed_jtag->reg_base + reg);
+}
+
+/******************************************************************************/
+static int aspeed_jtag_set_freq(struct jtag *jtag, u32 freq)
+{
+	struct aspeed_jtag_info *aspeed_jtag = jtag_priv(jtag);
+	u32 div;
+
+	/* SW mode frequency setting */
+	aspeed_jtag->sw_delay = DIV_ROUND_UP(NSEC_PER_SEC, freq);
+	JTAG_DBUG("sw mode delay = %d\n", aspeed_jtag->sw_delay);
+	/*
+	 * HW mode frequency setting
+	 * AST2600: TCK period = Period of PCLK * (JTAG14[10:0] + 1)
+	 * AST2500: TCK period = Period of PCLK * (JTAG14[10:0] + 1) * 2
+	 */
+	if (aspeed_jtag->config->jtag_version == 6)
+		div = DIV_ROUND_CLOSEST(aspeed_jtag->clkin, freq);
+	else
+		div = DIV_ROUND_CLOSEST(aspeed_jtag->clkin, freq * 2);
+	if (div >= 1)
+		div = div - 1;
+	if (div > JTAG_TCK_DIVISOR_MASK)
+		div = JTAG_TCK_DIVISOR_MASK;
+	JTAG_DBUG("%d target freq = %d div = %d", aspeed_jtag->clkin, freq,
+		  div);
+	/*
+	 * HW constraint:
+	 * AST2600 minimal TCK divisor = 7
+	 * AST2500 minimal TCK divisor = 1
+	 */
+	if (aspeed_jtag->config->jtag_version == 6) {
+		if (div < 7)
+			div = 7;
+		aspeed_jtag->tck_period = DIV_ROUND_UP_ULL(
+			(u64)NSEC_PER_SEC * (div + 1), aspeed_jtag->clkin);
+	} else if (aspeed_jtag->config->jtag_version == 0) {
+		if (div < 1)
+			div = 1;
+		aspeed_jtag->tck_period = DIV_ROUND_UP_ULL(
+			(u64)NSEC_PER_SEC * (div + 1) << 2, aspeed_jtag->clkin);
+	}
+	JTAG_DBUG("set div = %x, tck_period = %dns\n", div,
+		  aspeed_jtag->tck_period);
+
+	/*
+	 * At ast2500: Change clock divider may cause hardware logic confusion.
+	 * Enable software mode to assert the jtag hw logical before change
+	 * clock divider.
+	 */
+	if (aspeed_jtag->config->jtag_version == 0)
+		aspeed_jtag_write(aspeed_jtag,
+				  JTAG_SW_MODE_EN |
+					  aspeed_jtag_read(aspeed_jtag,
+							   ASPEED_JTAG_SW),
+				  ASPEED_JTAG_SW);
+	aspeed_jtag_write(aspeed_jtag,
+			  ((aspeed_jtag_read(aspeed_jtag, ASPEED_JTAG_TCK) &
+			    ~JTAG_TCK_DIVISOR_MASK) |
+			   div),
+			  ASPEED_JTAG_TCK);
+	if (aspeed_jtag->config->jtag_version == 0) {
+		aspeed_jtag_write(aspeed_jtag, 0, ASPEED_JTAG_SW);
+		aspeed_jtag->sts = JTAG_STATE_IDLE;
+	}
+	return 0;
+}
+
+static int aspeed_jtag_get_freq(struct jtag *jtag, u32 *freq)
+{
+	struct aspeed_jtag_info *aspeed_jtag = jtag_priv(jtag);
+
+	if (aspeed_jtag->config->jtag_version == 6) {
+		/* TCK period = Period of PCLK * (JTAG14[10:0] + 1) */
+		*freq = aspeed_jtag->clkin /
+		       (JTAG_GET_TCK_DIVISOR(aspeed_jtag_read(
+				aspeed_jtag, ASPEED_JTAG_TCK)) + 1);
+	} else if (aspeed_jtag->config->jtag_version == 0) {
+		/* TCK period = Period of PCLK * (JTAG14[10:0] + 1) * 2 */
+		*freq = (aspeed_jtag->clkin /
+			(JTAG_GET_TCK_DIVISOR(aspeed_jtag_read(
+				 aspeed_jtag, ASPEED_JTAG_TCK)) + 1)) >> 1;
+	} else {
+		/* unknown jtag version */
+		*freq = 0;
+	}
+	return 0;
+}
+/******************************************************************************/
+static u8 TCK_Cycle(struct aspeed_jtag_info *aspeed_jtag, u8 TMS, u8 TDI)
+{
+	u8 tdo;
+
+	/* IEEE 1149.1
+	 * TMS & TDI shall be sampled by the test logic on the rising edge
+	 * test logic shall change TDO on the falling edge
+	 */
+	// TCK = 0
+	aspeed_jtag_write(aspeed_jtag,
+			  JTAG_SW_MODE_EN | (TMS * JTAG_SW_MODE_TMS) |
+				  (TDI * JTAG_SW_MODE_TDIO),
+			  ASPEED_JTAG_SW);
+
+	/* Target device have their operating frequency*/
+	ndelay(aspeed_jtag->sw_delay);
+
+	// TCK = 1
+	aspeed_jtag_write(aspeed_jtag,
+			  JTAG_SW_MODE_EN | JTAG_SW_MODE_TCK |
+				  (TMS * JTAG_SW_MODE_TMS) |
+				  (TDI * JTAG_SW_MODE_TDIO),
+			  ASPEED_JTAG_SW);
+
+	ndelay(aspeed_jtag->sw_delay);
+	/* Sampled TDI(slave, master's TDO) on the rising edge */
+	if (aspeed_jtag_read(aspeed_jtag, ASPEED_JTAG_SW) & JTAG_SW_MODE_TDIO)
+		tdo = 1;
+	else
+		tdo = 0;
+
+	JTAG_DBUG("tms: %d tdi: %d tdo: %d", TMS, TDI, tdo);
+
+	return tdo;
+}
+
+static int aspeed_jtag_sw_set_tap_state(struct aspeed_jtag_info *aspeed_jtag,
+				      enum jtag_tapstate endstate)
+{
+	int i = 0;
+	enum jtag_tapstate from, to;
+
+	from = aspeed_jtag->sts;
+	to = endstate;
+	/* Send 8 TMS high to ensure jtag tap state go to TLRESET */
+	if (endstate == JTAG_STATE_TLRESET)
+		for (i = 0; i < 8 ; i++)
+			TCK_Cycle(aspeed_jtag, ((0xff >> i) & 0x1), 0);
+	else
+		for (i = 0; i < _tms_cycle_lookup[from][to].count; i++)
+			TCK_Cycle(aspeed_jtag,
+				  ((_tms_cycle_lookup[from][to].tmsbits >> i) &
+				   0x1),
+				  0);
+	aspeed_jtag->sts = endstate;
+	JTAG_DBUG("go to %d", endstate);
+	return 0;
+}
+
+/******************************************************************************/
+static void aspeed_jtag_wait_instruction_pause_complete(
+	struct aspeed_jtag_info *aspeed_jtag)
+{
+	wait_event_interruptible(aspeed_jtag->jtag_wq,
+				 (aspeed_jtag->flag & JTAG_INST_PAUSE));
+	JTAG_DBUG("\n");
+	aspeed_jtag->flag &= ~JTAG_INST_PAUSE;
+}
+static void
+aspeed_jtag_wait_instruction_complete(struct aspeed_jtag_info *aspeed_jtag)
+{
+	wait_event_interruptible(aspeed_jtag->jtag_wq,
+				 (aspeed_jtag->flag & JTAG_INST_COMPLETE));
+	JTAG_DBUG("\n");
+	aspeed_jtag->flag &= ~JTAG_INST_COMPLETE;
+}
+static void
+aspeed_jtag_wait_data_pause_complete(struct aspeed_jtag_info *aspeed_jtag)
+{
+	wait_event_interruptible(aspeed_jtag->jtag_wq,
+				 (aspeed_jtag->flag & JTAG_DATA_PAUSE));
+	JTAG_DBUG("\n");
+	aspeed_jtag->flag &= ~JTAG_DATA_PAUSE;
+}
+static void aspeed_jtag_wait_data_complete(struct aspeed_jtag_info *aspeed_jtag)
+{
+	wait_event_interruptible(aspeed_jtag->jtag_wq,
+				 (aspeed_jtag->flag & JTAG_DATA_COMPLETE));
+	JTAG_DBUG("\n");
+	aspeed_jtag->flag &= ~JTAG_DATA_COMPLETE;
+}
+static int aspeed_jtag_run_to_tlr(struct aspeed_jtag_info *aspeed_jtag)
+{
+	if (aspeed_jtag->sts == JTAG_STATE_PAUSEIR)
+		aspeed_jtag_write(aspeed_jtag, JTAG_INST_COMPLETE_EN,
+				ASPEED_JTAG_ISR);
+	else if (aspeed_jtag->sts == JTAG_STATE_PAUSEDR)
+		aspeed_jtag_write(aspeed_jtag, JTAG_DATA_COMPLETE_EN,
+				  ASPEED_JTAG_ISR);
+	aspeed_jtag_write(aspeed_jtag,
+			  JTAG_ENG_EN | JTAG_ENG_OUT_EN | JTAG_FORCE_TMS,
+			  ASPEED_JTAG_CTRL); // x TMS high + 1 TMS low
+	if (aspeed_jtag->sts == JTAG_STATE_PAUSEIR)
+		aspeed_jtag_wait_instruction_complete(aspeed_jtag);
+	else if (aspeed_jtag->sts == JTAG_STATE_PAUSEDR)
+		aspeed_jtag_wait_data_complete(aspeed_jtag);
+	/* After that the fsm will go to idle state: hw constraint */
+	aspeed_jtag->sts = JTAG_STATE_IDLE;
+	return 0;
+}
+
+static int aspeed_jtag_run_to_idle(struct aspeed_jtag_info *aspeed_jtag)
+{
+	if (aspeed_jtag->sts == JTAG_STATE_IDLE) {
+		/* nothing to do */
+	} else if (aspeed_jtag->sts == JTAG_STATE_PAUSEDR) {
+		aspeed_jtag_write(aspeed_jtag, JTAG_DATA_COMPLETE_EN,
+					  ASPEED_JTAG_ISR);
+		if (aspeed_jtag->config->jtag_version == 6) {
+			aspeed_jtag_write(aspeed_jtag,
+					JTAG_ENG_EN | JTAG_ENG_OUT_EN |
+						JTAG_G6_TERMINATE_XFER |
+						JTAG_DATA_EN,
+					ASPEED_JTAG_CTRL);
+		} else {
+			aspeed_jtag_write(aspeed_jtag,
+					  JTAG_ENG_EN | JTAG_ENG_OUT_EN |
+						  JTAG_TERMINATE_DATA |
+						  JTAG_DATA_EN,
+					  ASPEED_JTAG_CTRL);
+		}
+		aspeed_jtag_wait_data_complete(aspeed_jtag);
+	} else if (aspeed_jtag->sts == JTAG_STATE_PAUSEIR) {
+		aspeed_jtag_write(aspeed_jtag, JTAG_INST_COMPLETE_EN,
+					  ASPEED_JTAG_ISR);
+		if (aspeed_jtag->config->jtag_version == 6) {
+			aspeed_jtag_write(aspeed_jtag,
+					JTAG_ENG_EN | JTAG_ENG_OUT_EN |
+						JTAG_G6_TERMINATE_XFER |
+						JTAG_G6_INST_EN,
+					ASPEED_JTAG_CTRL);
+		} else {
+			aspeed_jtag_write(aspeed_jtag,
+					JTAG_ENG_EN | JTAG_ENG_OUT_EN |
+						JTAG_TERMINATE_INST |
+						JTAG_INST_EN,
+					ASPEED_JTAG_CTRL);
+		}
+		aspeed_jtag_wait_instruction_complete(aspeed_jtag);
+	} else {
+		pr_err("Should not get here unless aspeed_jtag->sts error!");
+		return -EFAULT;
+	}
+	aspeed_jtag->sts = JTAG_STATE_IDLE;
+	return 0;
+}
+
+static int aspeed_jtag_hw_set_tap_state(struct aspeed_jtag_info *aspeed_jtag,
+				      enum jtag_tapstate endstate)
+{
+	int ret;
+
+	aspeed_jtag_write(aspeed_jtag, 0, ASPEED_JTAG_SW); //dis sw mode
+	mdelay(2);
+	if (endstate == JTAG_STATE_TLRESET) {
+		ret = aspeed_jtag_run_to_tlr(aspeed_jtag);
+	} else if (endstate == JTAG_STATE_IDLE) {
+		ret = aspeed_jtag_run_to_idle(aspeed_jtag);
+	} else {
+		/* other stable state will auto handle by hardware */
+		return 0;
+	}
+	return ret;
+}
+
+/******************************************************************************/
+/* JTAG_reset() is to generate at leaspeed 9 TMS high and
+ * 1 TMS low to force devices into Run-Test/Idle State
+ */
+static int aspeed_jtag_status_set(struct jtag *jtag,
+				  struct jtag_tap_state *tapstate)
+{
+	struct aspeed_jtag_info *aspeed_jtag = jtag_priv(jtag);
+	int ret;
+	uint32_t i;
+
+	if (aspeed_jtag->mode == JTAG_XFER_HW_MODE) {
+		if (tapstate->reset == JTAG_FORCE_RESET)
+			aspeed_jtag_hw_set_tap_state(aspeed_jtag,
+						     JTAG_STATE_TLRESET);
+		ret = aspeed_jtag_hw_set_tap_state(aspeed_jtag,
+						   tapstate->endstate);
+		for (i = 0; i < tapstate->tck; i++)
+			ndelay(aspeed_jtag->tck_period);
+	} else {
+		if (tapstate->reset == JTAG_FORCE_RESET)
+			aspeed_jtag_sw_set_tap_state(aspeed_jtag,
+						     JTAG_STATE_TLRESET);
+		ret = aspeed_jtag_sw_set_tap_state(aspeed_jtag,
+						   tapstate->endstate);
+		for (i = 0; i < tapstate->tck; i++)
+			TCK_Cycle(aspeed_jtag, 0, 0);
+	}
+	if (ret)
+		return ret;
+	return 0;
+}
+
+static int aspeed_jtag_status_get(struct jtag *jtag, u32 *status)
+{
+	struct aspeed_jtag_info *aspeed_jtag = jtag_priv(jtag);
+
+	*status = aspeed_jtag->sts;
+	return 0;
+}
+static void aspeed_sw_jtag_xfer(struct aspeed_jtag_info *aspeed_jtag,
+				struct jtag_xfer *xfer, u8 *xfer_data)
+{
+	unsigned int index = 0;
+	u32 shift_bits = 0;
+	u8 tdi = 0, tdo = 0, tdo_buff = 0;
+	u32 remain_xfer = xfer->length;
+
+	if (xfer->type == JTAG_SIR_XFER)
+		aspeed_jtag_sw_set_tap_state(aspeed_jtag, JTAG_STATE_SHIFTIR);
+	else
+		aspeed_jtag_sw_set_tap_state(aspeed_jtag, JTAG_STATE_SHIFTDR);
+
+	while (remain_xfer) {
+		tdi = (xfer_data[index]) >> (shift_bits % 8) & (0x1);
+		if (remain_xfer == 1)
+			tdo = TCK_Cycle(aspeed_jtag, 1, tdi); // go to Exit1-IR
+		else
+			tdo = TCK_Cycle(aspeed_jtag, 0, tdi); // go to IRShift
+		tdo_buff |= (tdo << (shift_bits % 8));
+		shift_bits++;
+		remain_xfer--;
+		if ((shift_bits % 8) == 0) {
+			xfer_data[index] = tdo_buff;
+			tdo_buff = 0;
+			index++;
+		}
+	}
+	TCK_Cycle(aspeed_jtag, 0, 0);
+	if (xfer->type == JTAG_SIR_XFER)
+		aspeed_jtag->sts = JTAG_STATE_PAUSEIR;
+	else
+		aspeed_jtag->sts = JTAG_STATE_PAUSEDR;
+	aspeed_jtag_sw_set_tap_state(aspeed_jtag, xfer->endstate);
+}
+static int aspeed_hw_ir_scan(struct aspeed_jtag_info *aspeed_jtag,
+			     enum jtag_tapstate endstate, u32 shift_bits)
+{
+	if (endstate == JTAG_STATE_PAUSEIR) {
+		aspeed_jtag_write(aspeed_jtag, JTAG_INST_PAUSE_EN,
+					  ASPEED_JTAG_ISR);
+		if (aspeed_jtag->config->jtag_version == 6) {
+			aspeed_jtag_write(
+				aspeed_jtag,
+				JTAG_ENG_EN | JTAG_ENG_OUT_EN |
+					JTAG_G6_SET_XFER_LEN(shift_bits),
+				ASPEED_JTAG_CTRL);
+			aspeed_jtag_write(
+				aspeed_jtag,
+				JTAG_ENG_EN | JTAG_ENG_OUT_EN |
+					JTAG_G6_SET_XFER_LEN(shift_bits) |
+					JTAG_G6_INST_EN,
+				ASPEED_JTAG_CTRL);
+		} else {
+			if (aspeed_jtag->sts == JTAG_STATE_PAUSEDR)
+				aspeed_jtag_write(aspeed_jtag,
+						  JTAG_INST_PAUSE_EN |
+							  JTAG_DATA_COMPLETE_EN,
+						  ASPEED_JTAG_ISR);
+			aspeed_jtag_write(aspeed_jtag,
+					  JTAG_ENG_EN | JTAG_ENG_OUT_EN |
+						  JTAG_SET_INST_LEN(shift_bits),
+					  ASPEED_JTAG_CTRL);
+			aspeed_jtag_write(
+				aspeed_jtag,
+				JTAG_ENG_EN | JTAG_ENG_OUT_EN |
+					JTAG_SET_INST_LEN(shift_bits) |
+					JTAG_INST_EN,
+				ASPEED_JTAG_CTRL);
+			if (aspeed_jtag->sts == JTAG_STATE_PAUSEDR)
+				aspeed_jtag_wait_data_complete(aspeed_jtag);
+		}
+		aspeed_jtag_wait_instruction_pause_complete(aspeed_jtag);
+		aspeed_jtag->sts = JTAG_STATE_PAUSEIR;
+	} else if (endstate == JTAG_STATE_IDLE) {
+		aspeed_jtag_write(aspeed_jtag, JTAG_INST_COMPLETE_EN,
+					  ASPEED_JTAG_ISR);
+		if (aspeed_jtag->config->jtag_version == 6) {
+			aspeed_jtag_write(
+				aspeed_jtag,
+				JTAG_ENG_EN | JTAG_ENG_OUT_EN |
+					JTAG_G6_LAST_XFER |
+					JTAG_G6_SET_XFER_LEN(shift_bits),
+				ASPEED_JTAG_CTRL);
+			aspeed_jtag_write(
+				aspeed_jtag,
+				JTAG_ENG_EN | JTAG_ENG_OUT_EN |
+					JTAG_G6_LAST_XFER |
+					JTAG_G6_SET_XFER_LEN(shift_bits) |
+					JTAG_G6_INST_EN,
+				ASPEED_JTAG_CTRL);
+		} else {
+			aspeed_jtag_write(aspeed_jtag,
+					  JTAG_ENG_EN | JTAG_ENG_OUT_EN |
+						  JTAG_LAST_INST |
+						  JTAG_SET_INST_LEN(shift_bits),
+					  ASPEED_JTAG_CTRL);
+			aspeed_jtag_write(
+				aspeed_jtag,
+				JTAG_ENG_EN | JTAG_ENG_OUT_EN | JTAG_LAST_INST |
+					JTAG_SET_INST_LEN(shift_bits) |
+					JTAG_INST_EN,
+				ASPEED_JTAG_CTRL);
+		}
+		aspeed_jtag_wait_instruction_complete(aspeed_jtag);
+		aspeed_jtag->sts = JTAG_STATE_IDLE;
+	} else {
+		pr_err("End state %d not support", endstate);
+		return -EFAULT;
+	}
+	return 0;
+}
+static int aspeed_hw_dr_scan(struct aspeed_jtag_info *aspeed_jtag,
+			     enum jtag_tapstate endstate, u32 shift_bits)
+{
+	if (endstate == JTAG_STATE_PAUSEDR) {
+		aspeed_jtag_write(aspeed_jtag, JTAG_DATA_PAUSE_EN,
+					  ASPEED_JTAG_ISR);
+		if (aspeed_jtag->config->jtag_version == 6) {
+			aspeed_jtag_write(
+				aspeed_jtag,
+				JTAG_ENG_EN | JTAG_ENG_OUT_EN |
+					JTAG_G6_SET_XFER_LEN(shift_bits),
+				ASPEED_JTAG_CTRL);
+			aspeed_jtag_write(
+				aspeed_jtag,
+				JTAG_ENG_EN | JTAG_ENG_OUT_EN |
+					JTAG_G6_SET_XFER_LEN(shift_bits) |
+					JTAG_DATA_EN,
+				ASPEED_JTAG_CTRL);
+		} else {
+			if (aspeed_jtag->sts == JTAG_STATE_PAUSEIR)
+				aspeed_jtag_write(aspeed_jtag,
+						  JTAG_DATA_PAUSE_EN |
+							  JTAG_INST_COMPLETE_EN,
+						  ASPEED_JTAG_ISR);
+			aspeed_jtag_write(aspeed_jtag,
+					  JTAG_ENG_EN | JTAG_ENG_OUT_EN |
+						  JTAG_DATA_LEN(shift_bits),
+					  ASPEED_JTAG_CTRL);
+			aspeed_jtag_write(aspeed_jtag,
+					  JTAG_ENG_EN | JTAG_ENG_OUT_EN |
+						  JTAG_DATA_LEN(shift_bits) |
+						  JTAG_DATA_EN,
+					  ASPEED_JTAG_CTRL);
+			if (aspeed_jtag->sts == JTAG_STATE_PAUSEIR)
+				aspeed_jtag_wait_instruction_complete(
+					aspeed_jtag);
+		}
+		aspeed_jtag_wait_data_pause_complete(aspeed_jtag);
+		aspeed_jtag->sts = JTAG_STATE_PAUSEDR;
+	} else if (endstate == JTAG_STATE_IDLE) {
+		aspeed_jtag_write(aspeed_jtag, JTAG_DATA_COMPLETE_EN,
+					  ASPEED_JTAG_ISR);
+		if (aspeed_jtag->config->jtag_version == 6) {
+			aspeed_jtag_write(
+				aspeed_jtag,
+				JTAG_ENG_EN | JTAG_ENG_OUT_EN |
+					JTAG_G6_LAST_XFER |
+					JTAG_G6_SET_XFER_LEN(shift_bits),
+				ASPEED_JTAG_CTRL);
+			aspeed_jtag_write(
+				aspeed_jtag,
+				JTAG_ENG_EN | JTAG_ENG_OUT_EN |
+					JTAG_G6_LAST_XFER |
+					JTAG_G6_SET_XFER_LEN(shift_bits) |
+					JTAG_DATA_EN,
+				ASPEED_JTAG_CTRL);
+		} else {
+			aspeed_jtag_write(aspeed_jtag,
+					  JTAG_ENG_EN | JTAG_ENG_OUT_EN |
+						  JTAG_LAST_DATA |
+						  JTAG_DATA_LEN(shift_bits),
+					  ASPEED_JTAG_CTRL);
+			aspeed_jtag_write(aspeed_jtag,
+					  JTAG_ENG_EN | JTAG_ENG_OUT_EN |
+						  JTAG_LAST_DATA |
+						  JTAG_DATA_LEN(shift_bits) |
+						  JTAG_DATA_EN,
+					  ASPEED_JTAG_CTRL);
+		}
+		aspeed_jtag_wait_data_complete(aspeed_jtag);
+		aspeed_jtag->sts = JTAG_STATE_IDLE;
+	} else {
+		pr_err("End state %d not support", endstate);
+		return -EFAULT;
+	}
+	return 0;
+}
+static void aspeed_hw_jtag_xfer(struct aspeed_jtag_info *aspeed_jtag,
+				struct jtag_xfer *xfer, u8 *xfer_data)
+{
+	unsigned int index = 0;
+	u32 shift_bits = 0;
+	u32 remain_xfer = xfer->length;
+	int i, tmp_idx = 0;
+	u32 fifo_reg = xfer->type ? ASPEED_JTAG_DATA : ASPEED_JTAG_INST;
+	u32 *xfer_data_32 = (u32 *)xfer_data;
+
+	aspeed_jtag_write(aspeed_jtag, 0, ASPEED_JTAG_SW); //dis sw mode
+
+	while (remain_xfer) {
+		if (remain_xfer > aspeed_jtag->config->jtag_buff_len) {
+			shift_bits = aspeed_jtag->config->jtag_buff_len;
+			tmp_idx = shift_bits / 32;
+			for (i = 0; i < tmp_idx; i++)
+				aspeed_jtag_write(aspeed_jtag,
+						  xfer_data_32[index + i],
+						  fifo_reg);
+			/*
+			 * Add 1 tck period delay to avoid jtag hardware
+			 * transfer will get wrong fifo pointer issue.
+			 */
+			ndelay(aspeed_jtag->tck_period);
+			if (xfer->type == JTAG_SIR_XFER)
+				aspeed_hw_ir_scan(aspeed_jtag,
+						  JTAG_STATE_PAUSEIR,
+						  shift_bits);
+			else
+				aspeed_hw_dr_scan(aspeed_jtag,
+						  JTAG_STATE_PAUSEDR,
+						  shift_bits);
+		} else {
+			shift_bits = remain_xfer;
+			tmp_idx = shift_bits / 32;
+			if (shift_bits % 32)
+				tmp_idx += 1;
+			for (i = 0; i < tmp_idx; i++)
+				aspeed_jtag_write(aspeed_jtag,
+						  xfer_data_32[index + i],
+						  fifo_reg);
+			ndelay(aspeed_jtag->tck_period);
+			if (xfer->type == JTAG_SIR_XFER)
+				aspeed_hw_ir_scan(aspeed_jtag, xfer->endstate,
+						  shift_bits);
+			else
+				aspeed_hw_dr_scan(aspeed_jtag, xfer->endstate,
+						  shift_bits);
+		}
+
+		remain_xfer = remain_xfer - shift_bits;
+
+		//handle tdo data
+		tmp_idx = shift_bits / 32;
+		if (shift_bits % 32)
+			tmp_idx += 1;
+		for (i = 0; i < tmp_idx; i++) {
+			if (shift_bits < 32)
+				xfer_data_32[index + i] =
+					aspeed_jtag_read(aspeed_jtag,
+							 fifo_reg) >>
+					(32 - shift_bits);
+			else
+				xfer_data_32[index + i] =
+					aspeed_jtag_read(aspeed_jtag, fifo_reg);
+			JTAG_DBUG("TDO[%d]: %x\n", index + i,
+				  xfer_data_32[index + i]);
+			shift_bits -= 32;
+		}
+		index += tmp_idx;
+	}
+}
+
+static int aspeed_jtag_xfer(struct jtag *jtag, struct jtag_xfer *xfer,
+			    u8 *xfer_data)
+{
+	struct aspeed_jtag_info *aspeed_jtag = jtag_priv(jtag);
+
+	JTAG_DBUG("%s mode, END : %d, len : %d\n",
+		  aspeed_jtag->mode ? "HW" : "SW", xfer->endstate,
+		  xfer->length);
+
+	if (aspeed_jtag->mode == JTAG_XFER_HW_MODE)
+		aspeed_hw_jtag_xfer(aspeed_jtag, xfer, xfer_data);
+	else
+		aspeed_sw_jtag_xfer(aspeed_jtag, xfer, xfer_data);
+
+	return 0;
+}
+
+static irqreturn_t aspeed_jtag_isr(int this_irq, void *dev_id)
+{
+	u32 status;
+	struct aspeed_jtag_info *aspeed_jtag = dev_id;
+
+	status = aspeed_jtag_read(aspeed_jtag, ASPEED_JTAG_ISR);
+	JTAG_DBUG("sts %x\n", status);
+
+	if (status & JTAG_INST_PAUSE) {
+		aspeed_jtag_write(aspeed_jtag, JTAG_INST_PAUSE | (status & 0xf),
+				  ASPEED_JTAG_ISR);
+		aspeed_jtag->flag |= JTAG_INST_PAUSE;
+	}
+
+	if (status & JTAG_INST_COMPLETE) {
+		aspeed_jtag_write(aspeed_jtag,
+				  JTAG_INST_COMPLETE | (status & 0xf),
+				  ASPEED_JTAG_ISR);
+		aspeed_jtag->flag |= JTAG_INST_COMPLETE;
+	}
+
+	if (status & JTAG_DATA_PAUSE) {
+		aspeed_jtag_write(aspeed_jtag, JTAG_DATA_PAUSE | (status & 0xf),
+				  ASPEED_JTAG_ISR);
+		aspeed_jtag->flag |= JTAG_DATA_PAUSE;
+	}
+
+	if (status & JTAG_DATA_COMPLETE) {
+		aspeed_jtag_write(aspeed_jtag,
+				  JTAG_DATA_COMPLETE | (status & 0xf),
+				  ASPEED_JTAG_ISR);
+		aspeed_jtag->flag |= JTAG_DATA_COMPLETE;
+	}
+
+	if (aspeed_jtag->flag) {
+		wake_up_interruptible(&aspeed_jtag->jtag_wq);
+		return IRQ_HANDLED;
+	}
+	pr_err("TODO Check JTAG's interrupt %x\n",
+		aspeed_jtag_read(aspeed_jtag, ASPEED_JTAG_ISR));
+	return IRQ_NONE;
+}
+
+
+static struct aspeed_jtag_config jtag_config = {
+	.jtag_version = 0,
+	.jtag_buff_len = 32,
+};
+
+static struct aspeed_jtag_config jtag_g6_config = {
+	.jtag_version = 6,
+	.jtag_buff_len = 512,
+};
+
+static const struct of_device_id aspeed_jtag_of_matches[] = {
+	{
+		.compatible = "aspeed,ast2400-jtag",
+		.data = &jtag_config,
+	},
+	{
+		.compatible = "aspeed,ast2500-jtag",
+		.data = &jtag_config,
+	},
+	{
+		.compatible = "aspeed,ast2600-jtag",
+		.data = &jtag_g6_config,
+	},
+	{},
+};
+MODULE_DEVICE_TABLE(of, aspeed_jtag_of_matches);
+
+static int aspeed_jtag_bitbang(struct jtag *jtag,
+			       struct bitbang_packet *bitbang,
+			       struct tck_bitbang *bitbang_data)
+{
+	struct aspeed_jtag_info *aspeed_jtag = jtag_priv(jtag);
+	int i = 0;
+
+	for (i = 0; i < bitbang->length; i++) {
+		bitbang_data[i].tdo =
+			TCK_Cycle(aspeed_jtag, bitbang_data[i].tms,
+					      bitbang_data[i].tdi);
+	}
+	return 0;
+}
+
+static int aspeed_jtag_mode_set(struct jtag *jtag, struct jtag_mode *jtag_mode)
+{
+	struct aspeed_jtag_info *aspeed_jtag = jtag_priv(jtag);
+
+	switch (jtag_mode->feature) {
+	case JTAG_XFER_MODE:
+		aspeed_jtag->mode = jtag_mode->mode;
+		break;
+	case JTAG_CONTROL_MODE:
+		return -ENOTSUPP;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int aspeed_jtag_enable(struct jtag *jtag)
+{
+	return 0;
+}
+
+static int aspeed_jtag_disable(struct jtag *jtag)
+{
+	return 0;
+}
+
+static const struct jtag_ops aspeed_jtag_ops = {
+	.freq_get = aspeed_jtag_get_freq,
+	.freq_set = aspeed_jtag_set_freq,
+	.status_get = aspeed_jtag_status_get,
+	.status_set = aspeed_jtag_status_set,
+	.xfer = aspeed_jtag_xfer,
+	.mode_set = aspeed_jtag_mode_set,
+	.bitbang = aspeed_jtag_bitbang,
+	.enable = aspeed_jtag_enable,
+	.disable = aspeed_jtag_disable,
+};
+
+static int aspeed_jtag_probe(struct platform_device *pdev)
+{
+	struct aspeed_jtag_info *aspeed_jtag;
+	struct jtag *jtag;
+	const struct of_device_id *jtag_dev_id;
+	struct resource *res;
+	int ret = 0;
+
+	jtag = jtag_alloc(&pdev->dev, sizeof(*aspeed_jtag),
+			  &aspeed_jtag_ops);
+	if (!jtag)
+		return -ENOMEM;
+
+	platform_set_drvdata(pdev, jtag);
+	aspeed_jtag = jtag_priv(jtag);
+	aspeed_jtag->dev = &pdev->dev;
+
+	jtag_dev_id = of_match_device(aspeed_jtag_of_matches, &pdev->dev);
+	if (!jtag_dev_id)
+		return -EINVAL;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (res == NULL) {
+		dev_err(&pdev->dev, "cannot get IORESOURCE_MEM\n");
+		ret = -ENOENT;
+		goto out;
+	}
+
+	aspeed_jtag->reg_base = devm_ioremap_resource(&pdev->dev, res);
+	if (!aspeed_jtag->reg_base) {
+		ret = -EIO;
+		goto out;
+	}
+
+	aspeed_jtag->irq = platform_get_irq(pdev, 0);
+	if (aspeed_jtag->irq < 0) {
+		dev_err(&pdev->dev, "no irq specified\n");
+		ret = -ENOENT;
+		goto out;
+	}
+	aspeed_jtag->reset =
+		devm_reset_control_get_exclusive(&pdev->dev, "jtag");
+	if (IS_ERR(aspeed_jtag->reset)) {
+		dev_err(&pdev->dev, "can't get jtag reset\n");
+		return PTR_ERR(aspeed_jtag->reset);
+	}
+
+	aspeed_jtag->clk = devm_clk_get(&pdev->dev, NULL);
+	if (IS_ERR(aspeed_jtag->clk)) {
+		dev_err(&pdev->dev, "no clock defined\n");
+		return -ENODEV;
+	}
+
+	aspeed_jtag->clkin = clk_get_rate(aspeed_jtag->clk);
+	dev_dbg(&pdev->dev, "aspeed_jtag->clkin %d\n", aspeed_jtag->clkin);
+
+	aspeed_jtag->config = (struct aspeed_jtag_config *)jtag_dev_id->data;
+	// SCU init
+	reset_control_assert(aspeed_jtag->reset);
+	udelay(3);
+	reset_control_deassert(aspeed_jtag->reset);
+
+	ret = devm_request_irq(&pdev->dev, aspeed_jtag->irq, aspeed_jtag_isr,
+			       0, dev_name(&pdev->dev), aspeed_jtag);
+	if (ret) {
+		dev_dbg(&pdev->dev, "JTAG Unable to get IRQ");
+		goto out;
+	}
+
+	// clear interrupt
+	aspeed_jtag_write(aspeed_jtag,
+			  JTAG_INST_PAUSE | JTAG_INST_COMPLETE |
+			  JTAG_DATA_PAUSE | JTAG_DATA_COMPLETE,
+			  ASPEED_JTAG_ISR);
+
+	aspeed_jtag->mode = JTAG_XFER_HW_MODE;
+	aspeed_jtag->flag = 0;
+	aspeed_jtag->sts = JTAG_STATE_IDLE;
+	init_waitqueue_head(&aspeed_jtag->jtag_wq);
+
+	aspeed_jtag_set_freq(jtag, TCK_FREQ);
+	/* Enable jtag clock */
+	aspeed_jtag_write(aspeed_jtag, JTAG_ENG_OUT_EN, ASPEED_JTAG_CTRL);
+
+	/* Initialize JTAG core structure*/
+	ret = devm_jtag_register(aspeed_jtag->dev, jtag);
+	if (ret)
+		goto out;
+
+	dev_info(&pdev->dev, "aspeed_jtag: driver successfully loaded.\n");
+
+	return 0;
+
+out:
+	reset_control_assert(aspeed_jtag->reset);
+	jtag_free(jtag);
+	dev_warn(&pdev->dev, "aspeed_jtag: driver init failed (ret=%d)!\n",
+		 ret);
+	return ret;
+}
+
+static int aspeed_jtag_remove(struct platform_device *pdev)
+{
+	struct jtag *jtag = platform_get_drvdata(pdev);
+	struct aspeed_jtag_info *aspeed_jtag;
+
+	aspeed_jtag = jtag_priv(jtag);
+	reset_control_assert(aspeed_jtag->reset);
+	jtag_free(jtag);
+	return 0;
+}
+
+static struct platform_driver aspeed_jtag_driver = {
+	.probe		= aspeed_jtag_probe,
+	.remove		= aspeed_jtag_remove,
+	.driver		= {
+		.name	= "aspeed-jtag",
+		.of_match_table = aspeed_jtag_of_matches,
+	},
+};
+
+module_platform_driver(aspeed_jtag_driver);
+
+MODULE_AUTHOR("Ryan Chen <ryan_chen@aspeedtech.com>");
+MODULE_DESCRIPTION("AST JTAG LIB Driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/jtag/jtag-aspeed.c b/drivers/jtag/jtag-aspeed.c
index 737756b79395..90e50a933298 100644
--- a/drivers/jtag/jtag-aspeed.c
+++ b/drivers/jtag/jtag-aspeed.c
@@ -17,8 +17,6 @@
 #include <linux/delay.h>
 #include <uapi/linux/jtag.h>

-#define ASPEED_SCU_RESET_JTAG		BIT(22)
-
 #define ASPEED_JTAG_DATA		0x00
 #define ASPEED_JTAG_INST		0x04
 #define ASPEED_JTAG_CTRL		0x08
@@ -29,7 +27,7 @@

 #define ASPEED_JTAG_DATA_MSB			0x01
 #define ASPEED_JTAG_DATA_CHUNK_SIZE		0x20
-#define ASPEED_JTAG_HW2_DATA_CHUNK_SIZE	160
+#define ASPEED_JTAG_HW2_DATA_CHUNK_SIZE	512

 /* ASPEED_JTAG_CTRL: Engine Control 24xx and 25xx series*/
 #define ASPEED_JTAG_CTL_ENG_EN		BIT(31)
@@ -101,7 +99,7 @@

 #define ASPEED_JTAG_TCK_WAIT		10
 #define ASPEED_JTAG_RESET_CNTR		10
-#define WAIT_ITERATIONS		75
+#define WAIT_ITERATIONS		300

 /* Use this macro to switch between HW mode 1(comment out) and 2(defined)  */
 //#define ASPEED_JTAG_HW_MODE_2_ENABLE	1
@@ -144,7 +142,7 @@
 #define ASPEED_JTAG_GBLCTRL_FIFO_CTRL_MODE	BIT(24)
 #define ASPEED_JTAG_GBLCTRL_UPDT_SHIFT(x)	(((x) & GENMASK(9, 7)) << 13)
 #define ASPEED_JTAG_GBLCTRL_STSHIFT(x)	(((x) & GENMASK(0, 0)) << 16)
-
+#define ASPEED_JTAG_GBLCTRL_TRST	BIT(15)
 #define ASPEED_JTAG_CLK_DIVISOR_MASK	GENMASK(11, 0)
 #define ASPEED_JTAG_CLK_GET_DIV(x)	((x) & ASPEED_JTAG_CLK_DIVISOR_MASK)

@@ -155,7 +153,15 @@
 /* ASPEED_JTAG_STAT: JTAG HW mode 2 status */
 #define ASPEED_JTAG_STAT_ENG_IDLE	BIT(0)

-/*#define USE_INTERRUPTS*/
+#define ASPEED_JTAG_MAX_PAD_SIZE	512
+
+/* Use this macro to set us delay to WA the intensive R/W FIFO usage issue */
+#define AST26XX_FIFO_UDELAY		2
+
+/* Use this macro to set us delay for JTAG Master Controller to be programmed */
+#define AST26XX_JTAG_CTRL_UDELAY	2
+
+#define USE_INTERRUPTS
 #define DEBUG_JTAG

 static const char * const regnames[] = {
@@ -188,10 +194,14 @@ struct aspeed_jtag {
 	u32				flag;
 	wait_queue_head_t		jtag_wq;
 	u32				mode;
+	enum jtag_tapstate		current_state;
 	const struct jtag_low_level_functions *llops;
+	u32 pad_data_one[ASPEED_JTAG_MAX_PAD_SIZE / 32];
+	u32 pad_data_zero[ASPEED_JTAG_MAX_PAD_SIZE / 32];
 };

-/* Multi generation support is enabled by fops and low level assped function
+/*
+ * Multi generation support is enabled by fops and low level assped function
  * mapping using asped_jtag_functions struct as config mechanism.
  */

@@ -206,6 +216,9 @@ struct jtag_low_level_functions {
 			u32 *data);
 	int (*xfer_hw)(struct aspeed_jtag *aspeed_jtag, struct jtag_xfer *xfer,
 		       u32 *data);
+	void (*xfer_hw_fifo_delay)(void);
+	void (*xfer_sw_delay)(struct aspeed_jtag *aspeed_jtag);
+	irqreturn_t (*jtag_interrupt)(s32 this_irq, void *dev_id);
 };

 struct aspeed_jtag_functions {
@@ -213,134 +226,6 @@ struct aspeed_jtag_functions {
 	const struct jtag_low_level_functions *aspeed_jtag_llops;
 };

-/*
- * This structure represents a TMS cycle, as expressed in a set of bits and a
- * count of bits (note: there are no start->end state transitions that require
- * more than 1 byte of TMS cycles)
- */
-struct tms_cycle {
-	unsigned char tmsbits;
-	unsigned char count;
-};
-
-/*
- * This is the complete set TMS cycles for going from any TAP state to any
- * other TAP state, following a "shortest path" rule.
- */
-static const struct tms_cycle _tms_cycle_lookup[][16] = {
-/*	    TLR        RTI        SelDR      CapDR      SDR        Ex1DR*/
-/* TLR  */{{0x00, 0}, {0x00, 1}, {0x02, 2}, {0x02, 3}, {0x02, 4}, {0x0a, 4},
-/*	    PDR        Ex2DR      UpdDR      SelIR      CapIR      SIR*/
-	    {0x0a, 5}, {0x2a, 6}, {0x1a, 5}, {0x06, 3}, {0x06, 4}, {0x06, 5},
-/*	    Ex1IR      PIR        Ex2IR      UpdIR*/
-	    {0x16, 5}, {0x16, 6}, {0x56, 7}, {0x36, 6} },
-
-/*	    TLR        RTI        SelDR      CapDR      SDR        Ex1DR*/
-/* RTI  */{{0x07, 3}, {0x00, 0}, {0x01, 1}, {0x01, 2}, {0x01, 3}, {0x05, 3},
-/*	    PDR        Ex2DR      UpdDR      SelIR      CapIR      SIR*/
-	    {0x05, 4}, {0x15, 5}, {0x0d, 4}, {0x03, 2}, {0x03, 3}, {0x03, 4},
-/*	    Ex1IR      PIR        Ex2IR      UpdIR*/
-	    {0x0b, 4}, {0x0b, 5}, {0x2b, 6}, {0x1b, 5} },
-
-/*	    TLR        RTI        SelDR      CapDR      SDR        Ex1DR*/
-/* SelDR*/{{0x03, 2}, {0x03, 3}, {0x00, 0}, {0x00, 1}, {0x00, 2}, {0x02, 2},
-/*	    PDR        Ex2DR      UpdDR      SelIR      CapIR      SIR*/
-	    {0x02, 3}, {0x0a, 4}, {0x06, 3}, {0x01, 1}, {0x01, 2}, {0x01, 3},
-/*	    Ex1IR      PIR        Ex2IR      UpdIR*/
-	    {0x05, 3}, {0x05, 4}, {0x15, 5}, {0x0d, 4} },
-
-/*	    TLR        RTI        SelDR      CapDR      SDR        Ex1DR*/
-/* CapDR*/{{0x1f, 5}, {0x03, 3}, {0x07, 3}, {0x00, 0}, {0x00, 1}, {0x01, 1},
-/*	    PDR        Ex2DR      UpdDR      SelIR      CapIR      SIR*/
-	    {0x01, 2}, {0x05, 3}, {0x03, 2}, {0x0f, 4}, {0x0f, 5}, {0x0f, 6},
-/*	    Ex1IR      PIR        Ex2IR      UpdIR*/
-	    {0x2f, 6}, {0x2f, 7}, {0xaf, 8}, {0x6f, 7} },
-
-/*	    TLR        RTI        SelDR      CapDR      SDR        Ex1DR*/
-/* SDR  */{{0x1f, 5}, {0x03, 3}, {0x07, 3}, {0x07, 4}, {0x00, 0}, {0x01, 1},
-/*	    PDR        Ex2DR      UpdDR      SelIR      CapIR      SIR*/
-	    {0x01, 2}, {0x05, 3}, {0x03, 2}, {0x0f, 4}, {0x0f, 5}, {0x0f, 6},
-/*	    Ex1IR      PIR        Ex2IR      UpdIR*/
-	    {0x2f, 6}, {0x2f, 7}, {0xaf, 8}, {0x6f, 7} },
-
-/*	    TLR        RTI        SelDR      CapDR      SDR        Ex1DR*/
-/* Ex1DR*/{{0x0f, 4}, {0x01, 2}, {0x03, 2}, {0x03, 3}, {0x02, 3}, {0x00, 0},
-/*	    PDR        Ex2DR      UpdDR      SelIR      CapIR      SIR*/
-	    {0x00, 1}, {0x02, 2}, {0x01, 1}, {0x07, 3}, {0x07, 4}, {0x07, 5},
-/*	    Ex1IR      PIR        Ex2IR      UpdIR*/
-	    {0x17, 5}, {0x17, 6}, {0x57, 7}, {0x37, 6} },
-
-/*	    TLR        RTI        SelDR      CapDR      SDR        Ex1DR*/
-/* PDR  */{{0x1f, 5}, {0x03, 3}, {0x07, 3}, {0x07, 4}, {0x01, 2}, {0x05, 3},
-/*	    PDR        Ex2DR      UpdDR      SelIR      CapIR      SIR*/
-	    {0x00, 0}, {0x01, 1}, {0x03, 2}, {0x0f, 4}, {0x0f, 5}, {0x0f, 6},
-/*	    Ex1IR      PIR        Ex2IR      UpdIR*/
-	    {0x2f, 6}, {0x2f, 7}, {0xaf, 8}, {0x6f, 7} },
-
-/*	    TLR        RTI        SelDR      CapDR      SDR        Ex1DR*/
-/* Ex2DR*/{{0x0f, 4}, {0x01, 2}, {0x03, 2}, {0x03, 3}, {0x00, 1}, {0x02, 2},
-/*	    PDR        Ex2DR      UpdDR      SelIR      CapIR      SIR*/
-	    {0x02, 3}, {0x00, 0}, {0x01, 1}, {0x07, 3}, {0x07, 4}, {0x07, 5},
-/*	    Ex1IR      PIR        Ex2IR      UpdIR*/
-	    {0x17, 5}, {0x17, 6}, {0x57, 7}, {0x37, 6} },
-
-/*	    TLR        RTI        SelDR      CapDR      SDR        Ex1DR*/
-/* UpdDR*/{{0x07, 3}, {0x00, 1}, {0x01, 1}, {0x01, 2}, {0x01, 3}, {0x05, 3},
-/*	    PDR        Ex2DR      UpdDR      SelIR      CapIR      SIR*/
-	    {0x05, 4}, {0x15, 5}, {0x00, 0}, {0x03, 2}, {0x03, 3}, {0x03, 4},
-/*	    Ex1IR      PIR        Ex2IR      UpdIR*/
-	    {0x0b, 4}, {0x0b, 5}, {0x2b, 6}, {0x1b, 5} },
-
-/*	    TLR        RTI        SelDR      CapDR      SDR        Ex1DR*/
-/* SelIR*/{{0x01, 1}, {0x01, 2}, {0x05, 3}, {0x05, 4}, {0x05, 5}, {0x15, 5},
-/*	    PDR        Ex2DR      UpdDR      SelIR      CapIR      SIR*/
-	    {0x15, 6}, {0x55, 7}, {0x35, 6}, {0x00, 0}, {0x00, 1}, {0x00, 2},
-/*	    Ex1IR      PIR        Ex2IR      UpdIR*/
-	    {0x02, 2}, {0x02, 3}, {0x0a, 4}, {0x06, 3} },
-
-/*	    TLR        RTI        SelDR      CapDR      SDR        Ex1DR*/
-/* CapIR*/{{0x1f, 5}, {0x03, 3}, {0x07, 3}, {0x07, 4}, {0x07, 5}, {0x17, 5},
-/*	    PDR        Ex2DR      UpdDR      SelIR      CapIR      SIR*/
-	    {0x17, 6}, {0x57, 7}, {0x37, 6}, {0x0f, 4}, {0x00, 0}, {0x00, 1},
-/*	    Ex1IR      PIR        Ex2IR      UpdIR*/
-	    {0x01, 1}, {0x01, 2}, {0x05, 3}, {0x03, 2} },
-
-/*	    TLR        RTI        SelDR      CapDR      SDR        Ex1DR*/
-/* SIR  */{{0x1f, 5}, {0x03, 3}, {0x07, 3}, {0x07, 4}, {0x07, 5}, {0x17, 5},
-/*	    PDR        Ex2DR      UpdDR      SelIR      CapIR      SIR*/
-	    {0x17, 6}, {0x57, 7}, {0x37, 6}, {0x0f, 4}, {0x0f, 5}, {0x00, 0},
-/*	    Ex1IR      PIR        Ex2IR      UpdIR*/
-	    {0x01, 1}, {0x01, 2}, {0x05, 3}, {0x03, 2} },
-
-/*	    TLR        RTI        SelDR      CapDR      SDR        Ex1DR*/
-/* Ex1IR*/{{0x0f, 4}, {0x01, 2}, {0x03, 2}, {0x03, 3}, {0x03, 4}, {0x0b, 4},
-/*	    PDR        Ex2DR      UpdDR      SelIR      CapIR      SIR*/
-	    {0x0b, 5}, {0x2b, 6}, {0x1b, 5}, {0x07, 3}, {0x07, 4}, {0x02, 3},
-/*	    Ex1IR      PIR        Ex2IR      UpdIR*/
-	    {0x00, 0}, {0x00, 1}, {0x02, 2}, {0x01, 1} },
-
-/*	    TLR        RTI        SelDR      CapDR      SDR        Ex1DR*/
-/* PIR  */{{0x1f, 5}, {0x03, 3}, {0x07, 3}, {0x07, 4}, {0x07, 5}, {0x17, 5},
-/*	    PDR        Ex2DR      UpdDR      SelIR      CapIR      SIR*/
-	    {0x17, 6}, {0x57, 7}, {0x37, 6}, {0x0f, 4}, {0x0f, 5}, {0x01, 2},
-/*	    Ex1IR      PIR        Ex2IR      UpdIR*/
-	    {0x05, 3}, {0x00, 0}, {0x01, 1}, {0x03, 2} },
-
-/*	    TLR        RTI        SelDR      CapDR      SDR        Ex1DR*/
-/* Ex2IR*/{{0x0f, 4}, {0x01, 2}, {0x03, 2}, {0x03, 3}, {0x03, 4}, {0x0b, 4},
-/*	    PDR        Ex2DR      UpdDR      SelIR      CapIR      SIR*/
-	    {0x0b, 5}, {0x2b, 6}, {0x1b, 5}, {0x07, 3}, {0x07, 4}, {0x00, 1},
-/*	    Ex1IR      PIR        Ex2IR      UpdIR*/
-	    {0x02, 2}, {0x02, 3}, {0x00, 0}, {0x01, 1} },
-
-/*	    TLR        RTI        SelDR      CapDR      SDR        Ex1DR*/
-/* UpdIR*/{{0x07, 3}, {0x00, 1}, {0x01, 1}, {0x01, 2}, {0x01, 3}, {0x05, 3},
-/*	    PDR        Ex2DR      UpdDR      SelIR      CapIR      SIR*/
-	    {0x05, 4}, {0x15, 5}, {0x0d, 4}, {0x03, 2}, {0x03, 3}, {0x03, 4},
-/*	    Ex1IR      PIR        Ex2IR      UpdIR*/
-	    {0x0b, 4}, {0x0b, 5}, {0x2b, 6}, {0x00, 0} },
-};
-
 #ifdef DEBUG_JTAG
 static char *end_status_str[] = { "tlr",   "idle",  "selDR", "capDR",
 				  "sDR",   "ex1DR", "pDR",   "ex2DR",
@@ -374,20 +259,14 @@ static int aspeed_jtag_freq_set(struct jtag *jtag, u32 freq)
 	u32 tck_val;
 	u16 div;

-	#ifdef DEBUG_JTAG
-		dev_dbg(aspeed_jtag->dev, "freq  = %d", freq);
-	#endif
 	if (!freq)
 		return -EINVAL;

 	apb_frq = clk_get_rate(aspeed_jtag->pclk);
 	if (!apb_frq)
-		return -ENOTSUPP;
+		return -EOPNOTSUPP;

 	div = (apb_frq - 1) / freq;
-	#ifdef DEBUG_JTAG
-		dev_dbg(aspeed_jtag->dev, "apb_frq  = %d, div=%d\n", apb_frq, div);
-	#endif
 	tck_val = aspeed_jtag_read(aspeed_jtag, ASPEED_JTAG_TCK);
 	aspeed_jtag_write(aspeed_jtag,
 			  (tck_val & ~ASPEED_JTAG_TCK_DIVISOR_MASK) | div,
@@ -407,7 +286,7 @@ static int aspeed_jtag_freq_set_26xx(struct jtag *jtag, u32 freq)

 	apb_frq = clk_get_rate(aspeed_jtag->pclk);
 	if (!apb_frq)
-		return -ENOTSUPP;
+		return -EOPNOTSUPP;

 	div = (apb_frq - 1) / freq;
 	tck_val = aspeed_jtag_read(aspeed_jtag, ASPEED_JTAG_GBLCTRL);
@@ -425,7 +304,7 @@ static int aspeed_jtag_freq_get(struct jtag *jtag, u32 *frq)

 	pclk = clk_get_rate(aspeed_jtag->pclk);
 	tck = aspeed_jtag_read(aspeed_jtag, ASPEED_JTAG_TCK);
-	*frq = pclk / (2 * (ASPEED_JTAG_TCK_GET_DIV(tck) + 1));
+	*frq = pclk / (ASPEED_JTAG_TCK_GET_DIV(tck) + 1);

 	return 0;
 }
@@ -451,6 +330,7 @@ static inline void aspeed_jtag_output_disable(struct aspeed_jtag *aspeed_jtag)
 static inline void
 aspeed_jtag_output_disable_26xx(struct aspeed_jtag *aspeed_jtag)
 {
+	aspeed_jtag_write(aspeed_jtag, 0, ASPEED_JTAG_CTRL);
 	aspeed_jtag_write(aspeed_jtag, 0, ASPEED_JTAG_GBLCTRL);
 }

@@ -484,11 +364,6 @@ static inline void aspeed_jtag_master_26xx(struct aspeed_jtag *aspeed_jtag)
 				  ASPEED_JTAG_GBLCTRL_ENG_MODE_EN |
 					  ASPEED_JTAG_GBLCTRL_ENG_OUT_EN,
 				  ASPEED_JTAG_GBLCTRL);
-
-		aspeed_jtag_write(aspeed_jtag,
-				  ASPEED_JTAG_INTCTRL_SHCPL_IRQ_EN |
-					  ASPEED_JTAG_INTCTRL_SHCPL_IRQ_STAT,
-				  ASPEED_JTAG_INTCTRL); /* Enable Interrupt */
 	} else {
 		aspeed_jtag_write(aspeed_jtag, 0, ASPEED_JTAG_GBLCTRL);
 		aspeed_jtag_write(aspeed_jtag,
@@ -500,17 +375,22 @@ static inline void aspeed_jtag_master_26xx(struct aspeed_jtag *aspeed_jtag)
 				  ASPEED_JTAG_SW_MODE_EN |
 					  ASPEED_JTAG_SW_MODE_TDIO,
 				  ASPEED_JTAG_SW);
-		aspeed_jtag_write(aspeed_jtag,
-				  ASPEED_JTAG_ISR_INST_PAUSE |
-					  ASPEED_JTAG_ISR_INST_COMPLETE |
-					  ASPEED_JTAG_ISR_DATA_PAUSE |
-					  ASPEED_JTAG_ISR_DATA_COMPLETE |
-					  ASPEED_JTAG_ISR_INST_PAUSE_EN |
-					  ASPEED_JTAG_ISR_INST_COMPLETE_EN |
-					  ASPEED_JTAG_ISR_DATA_PAUSE_EN |
-					  ASPEED_JTAG_ISR_DATA_COMPLETE_EN,
-				  ASPEED_JTAG_ISR); /* Enable Interrupt */
 	}
+	aspeed_jtag_write(aspeed_jtag,
+			  ASPEED_JTAG_INTCTRL_SHCPL_IRQ_EN |
+				  ASPEED_JTAG_INTCTRL_SHCPL_IRQ_STAT,
+			  ASPEED_JTAG_INTCTRL); /* Enable HW2 IRQ */
+
+	aspeed_jtag_write(aspeed_jtag,
+			  ASPEED_JTAG_ISR_INST_PAUSE |
+				  ASPEED_JTAG_ISR_INST_COMPLETE |
+				  ASPEED_JTAG_ISR_DATA_PAUSE |
+				  ASPEED_JTAG_ISR_DATA_COMPLETE |
+				  ASPEED_JTAG_ISR_INST_PAUSE_EN |
+				  ASPEED_JTAG_ISR_INST_COMPLETE_EN |
+				  ASPEED_JTAG_ISR_DATA_PAUSE_EN |
+				  ASPEED_JTAG_ISR_DATA_COMPLETE_EN,
+			  ASPEED_JTAG_ISR); /* Enable HW1 Interrupts */
 }

 static int aspeed_jtag_mode_set(struct jtag *jtag, struct jtag_mode *jtag_mode)
@@ -534,6 +414,18 @@ static int aspeed_jtag_mode_set(struct jtag *jtag, struct jtag_mode *jtag_mode)
 	return 0;
 }

+/*
+ * We read and write from an unused JTAG Master controller register in SW
+ * mode to create a delay in xfers.
+ * We found this mechanism better than any udelay or usleep option.
+ */
+static inline void aspeed_jtag_sw_delay_26xx(struct aspeed_jtag *aspeed_jtag)
+{
+	u32 read_reg = aspeed_jtag_read(aspeed_jtag, ASPEED_JTAG_PADCTRL1);
+
+	aspeed_jtag_write(aspeed_jtag, read_reg, ASPEED_JTAG_PADCTRL1);
+}
+
 static char aspeed_jtag_tck_cycle(struct aspeed_jtag *aspeed_jtag, u8 tms,
 				  u8 tdi)
 {
@@ -546,7 +438,11 @@ static char aspeed_jtag_tck_cycle(struct aspeed_jtag *aspeed_jtag, u8 tms,
 				  (tdi * ASPEED_JTAG_SW_MODE_TDIO),
 			  ASPEED_JTAG_SW);

-	aspeed_jtag_read(aspeed_jtag, ASPEED_JTAG_SW);
+	/* Wait until JTAG Master controller finishes the operation */
+	if (aspeed_jtag->llops->xfer_sw_delay)
+		aspeed_jtag->llops->xfer_sw_delay(aspeed_jtag);
+	else
+		aspeed_jtag_read(aspeed_jtag, ASPEED_JTAG_SW);

 	/* TCK = 1 */
 	aspeed_jtag_write(aspeed_jtag,
@@ -555,6 +451,10 @@ static char aspeed_jtag_tck_cycle(struct aspeed_jtag *aspeed_jtag, u8 tms,
 				  (tdi * ASPEED_JTAG_SW_MODE_TDIO),
 			  ASPEED_JTAG_SW);

+	/* Wait until JTAG Master controller finishes the operation */
+	if (aspeed_jtag->llops->xfer_sw_delay)
+		aspeed_jtag->llops->xfer_sw_delay(aspeed_jtag);
+
 	if (aspeed_jtag_read(aspeed_jtag, ASPEED_JTAG_SW) &
 	    ASPEED_JTAG_SW_MODE_TDIO)
 		tdo = 1;
@@ -577,6 +477,11 @@ static int aspeed_jtag_bitbang(struct jtag *jtag,
 	return 0;
 }

+static inline void aspeed_jtag_xfer_hw_fifo_delay_26xx(void)
+{
+	udelay(AST26XX_FIFO_UDELAY);
+}
+
 static int aspeed_jtag_isr_wait(struct aspeed_jtag *aspeed_jtag, u32 bit)
 {
 	int res = 0;
@@ -667,7 +572,7 @@ static void aspeed_jtag_set_tap_state(struct aspeed_jtag *aspeed_jtag,
 		aspeed_jtag_tck_cycle(aspeed_jtag,
 				      ((_tms_cycle_lookup[from][to].tmsbits
 				      >> i) & 0x1), 0);
-	aspeed_jtag->status = end_state;
+	aspeed_jtag->current_state = end_state;
 }

 static void aspeed_jtag_set_tap_state_sw(struct aspeed_jtag *aspeed_jtag,
@@ -679,7 +584,7 @@ static void aspeed_jtag_set_tap_state_sw(struct aspeed_jtag *aspeed_jtag,

 		for (i = 0; i < ASPEED_JTAG_RESET_CNTR; i++)
 			aspeed_jtag_tck_cycle(aspeed_jtag, 1, 0);
-		aspeed_jtag->status = JTAG_STATE_TLRESET;
+		aspeed_jtag->current_state = JTAG_STATE_TLRESET;
 	}

 	aspeed_jtag_set_tap_state(aspeed_jtag, tapstate->from,
@@ -711,11 +616,10 @@ static int aspeed_jtag_status_set(struct jtag *jtag,
 					  ASPEED_JTAG_CTL_ENG_OUT_EN |
 					  ASPEED_JTAG_CTL_FORCE_TMS,
 				  ASPEED_JTAG_CTRL);
-		//mdelay(1);
-		while(ASPEED_JTAG_CTL_FORCE_TMS & aspeed_jtag_read(aspeed_jtag, ASPEED_JTAG_CTRL));
+		mdelay(1);
 		aspeed_jtag_write(aspeed_jtag, ASPEED_JTAG_SW_TDIO,
 				  ASPEED_JTAG_SW);
-		aspeed_jtag->status = JTAG_STATE_TLRESET;
+		aspeed_jtag->current_state = JTAG_STATE_TLRESET;
 	}

 	return 0;
@@ -744,14 +648,12 @@ static void aspeed_jtag_set_tap_state_hw2(struct aspeed_jtag *aspeed_jtag,
 					  struct jtag_tap_state *tapstate)
 {
 	u32 reg_val;
-	u32 start_shift = ASPEED_JTAG_SHCTRL_START_SHIFT;
-	u32 tms_mask = 0;

 	/* x TMS high + 1 TMS low */
 	if (tapstate->reset) {
 		/* Disable sw mode */
 		aspeed_jtag_write(aspeed_jtag, 0, ASPEED_JTAG_SW);
-		mdelay(1);
+		udelay(AST26XX_JTAG_CTRL_UDELAY);
 		reg_val = aspeed_jtag_read(aspeed_jtag, ASPEED_JTAG_GBLCTRL);
 		aspeed_jtag_write(aspeed_jtag,
 				  reg_val | ASPEED_JTAG_GBLCTRL_ENG_MODE_EN |
@@ -759,29 +661,10 @@ static void aspeed_jtag_set_tap_state_hw2(struct aspeed_jtag *aspeed_jtag,
 					  ASPEED_JTAG_GBLCTRL_RESET_FIFO |
 					  ASPEED_JTAG_GBLCTRL_FORCE_TMS,
 				  ASPEED_JTAG_GBLCTRL);
-		mdelay(1);
-		aspeed_jtag->status = JTAG_STATE_TLRESET;
+		udelay(AST26XX_JTAG_CTRL_UDELAY);
+		aspeed_jtag->current_state = JTAG_STATE_TLRESET;
 		return;
 	}
-
-	if (tapstate->from != tapstate->endstate) {
-		aspeed_jtag_shctrl_tms_mask(tapstate->from, tapstate->endstate,
-					    JTAG_STATE_TLRESET,
-					    JTAG_STATE_TLRESET, start_shift,
-					    ASPEED_JTAG_END_SHIFT_DISABLED,
-					    &tms_mask);
-
-		/* Trigger a 0 bit transfer to execute pre tms flow*/
-		aspeed_jtag_write(aspeed_jtag,
-				  tms_mask | ASPEED_JTAG_SHCTRL_LWRDT_SHIFT(0),
-				  ASPEED_JTAG_SHCTRL);
-		aspeed_jtag_wait_shift_complete(aspeed_jtag);
-		reg_val = aspeed_jtag_read(aspeed_jtag, ASPEED_JTAG_GBLCTRL);
-		aspeed_jtag_write(aspeed_jtag,
-				  reg_val | ASPEED_JTAG_GBLCTRL_RESET_FIFO,
-				  ASPEED_JTAG_GBLCTRL);
-	}
-	aspeed_jtag->status = tapstate->endstate;
 }

 static int aspeed_jtag_status_set_26xx(struct jtag *jtag,
@@ -790,7 +673,9 @@ static int aspeed_jtag_status_set_26xx(struct jtag *jtag,
 	struct aspeed_jtag *aspeed_jtag = jtag_priv(jtag);

 #ifdef DEBUG_JTAG
-	dev_dbg(aspeed_jtag->dev, "Set TAP state: %s\n",
+	dev_dbg(aspeed_jtag->dev, "Set TAP state: status %s from %s to %s\n",
+		end_status_str[aspeed_jtag->current_state],
+		end_status_str[tapstate->from],
 		end_status_str[tapstate->endstate]);
 #endif

@@ -806,10 +691,10 @@ static int aspeed_jtag_status_set_26xx(struct jtag *jtag,
 static void aspeed_jtag_xfer_sw(struct aspeed_jtag *aspeed_jtag,
 				struct jtag_xfer *xfer, u32 *data)
 {
-	u32 remain_xfer = xfer->length;
-	u32 shift_bits = 0;
-	u32 index = 0;
-	u32 tdi;
+	unsigned long remain_xfer = xfer->length;
+	unsigned long shift_bits = 0;
+	unsigned long index = 0;
+	unsigned long tdi;
 	char tdo;

 #ifdef DEBUG_JTAG
@@ -990,10 +875,15 @@ static int aspeed_jtag_xfer_hw(struct aspeed_jtag *aspeed_jtag,
 	char shift_bits;
 	u32 data_reg;
 	u32 scan_end;
+	union pad_config padding;
+	int retval = 0;
+
+	padding.int_value = xfer->padding;

 #ifdef DEBUG_JTAG
-	dev_dbg(aspeed_jtag->dev, "HW JTAG SHIFT %s, length = %d\n",
-		(xfer->type == JTAG_SIR_XFER) ? "IR" : "DR", xfer->length);
+	dev_dbg(aspeed_jtag->dev, "HW JTAG SHIFT %s, length = %d pad = 0x%x\n",
+		(xfer->type == JTAG_SIR_XFER) ? "IR" : "DR", xfer->length,
+		xfer->padding);
 #endif
 	data_reg = xfer->type == JTAG_SIR_XFER ? ASPEED_JTAG_INST :
 						 ASPEED_JTAG_DATA;
@@ -1003,7 +893,31 @@ static int aspeed_jtag_xfer_hw(struct aspeed_jtag *aspeed_jtag,
 	    xfer->endstate == JTAG_STATE_PAUSEDR) {
 		scan_end = 0;
 	} else {
-		scan_end = 1;
+		if (padding.post_pad_number)
+			scan_end = 0;
+		else
+			scan_end = 1;
+	}
+
+	/* Perform pre padding */
+	if (padding.pre_pad_number) {
+		struct jtag_xfer pre_xfer = {
+			.type = xfer->type,
+			.direction = JTAG_WRITE_XFER,
+			.from = xfer->from,
+			.endstate = xfer->type == JTAG_SIR_XFER ?
+				    JTAG_STATE_SHIFTIR : JTAG_STATE_SHIFTDR,
+			.padding = 0,
+			.length = padding.pre_pad_number,
+		};
+		if (padding.pre_pad_number > ASPEED_JTAG_MAX_PAD_SIZE)
+			return -EINVAL;
+		retval = aspeed_jtag_xfer_hw(aspeed_jtag, &pre_xfer,
+					     padding.pad_data ?
+					     aspeed_jtag->pad_data_one :
+					     aspeed_jtag->pad_data_zero);
+		if (retval)
+			return retval;
 	}

 	while (remain_xfer) {
@@ -1011,6 +925,8 @@ static int aspeed_jtag_xfer_hw(struct aspeed_jtag *aspeed_jtag,
 			aspeed_jtag_write(aspeed_jtag, data[index], data_reg);
 		else
 			aspeed_jtag_write(aspeed_jtag, 0, data_reg);
+		if (aspeed_jtag->llops->xfer_hw_fifo_delay)
+			aspeed_jtag->llops->xfer_hw_fifo_delay();

 		if (remain_xfer > ASPEED_JTAG_DATA_CHUNK_SIZE) {
 #ifdef DEBUG_JTAG
@@ -1085,11 +1001,33 @@ static int aspeed_jtag_xfer_hw(struct aspeed_jtag *aspeed_jtag,
 				data[index] =
 					aspeed_jtag_read(aspeed_jtag, data_reg);
 			}
+			if (aspeed_jtag->llops->xfer_hw_fifo_delay)
+				aspeed_jtag->llops->xfer_hw_fifo_delay();
 		}

 		remain_xfer = remain_xfer - shift_bits;
 		index++;
 	}
+
+	/* Perform post padding */
+	if (padding.post_pad_number) {
+		struct jtag_xfer post_xfer = {
+			.type = xfer->type,
+			.direction = JTAG_WRITE_XFER,
+			.from = xfer->from,
+			.endstate = xfer->endstate,
+			.padding = 0,
+			.length = padding.post_pad_number,
+		};
+		if (padding.post_pad_number > ASPEED_JTAG_MAX_PAD_SIZE)
+			return -EINVAL;
+		retval = aspeed_jtag_xfer_hw(aspeed_jtag, &post_xfer,
+					     padding.pad_data ?
+					     aspeed_jtag->pad_data_one :
+					     aspeed_jtag->pad_data_zero);
+		if (retval)
+			return retval;
+	}
 	return 0;
 }

@@ -1128,42 +1066,82 @@ static int aspeed_jtag_xfer_hw2(struct aspeed_jtag *aspeed_jtag,
 	u32 reg_val;
 	enum jtag_tapstate shift;
 	enum jtag_tapstate exit;
+	enum jtag_tapstate pause;
+	enum jtag_tapstate endstate;
 	u32 start_shift;
 	u32 end_shift;
 	u32 tms_mask;

 	if (xfer->type == JTAG_SIR_XFER) {
-		data_reg = ASPEED_JTAG_SHDATA;
+		data_reg = ASPEED_JTAG_SHINST;
 		shift = JTAG_STATE_SHIFTIR;
+		pause = JTAG_STATE_PAUSEIR;
 		exit = JTAG_STATE_EXIT1IR;
 	} else {
 		data_reg = ASPEED_JTAG_SHDATA;
 		shift = JTAG_STATE_SHIFTDR;
+		pause = JTAG_STATE_PAUSEDR;
 		exit = JTAG_STATE_EXIT1DR;
 	}
 #ifdef DEBUG_JTAG
 	dev_dbg(aspeed_jtag->dev,
-		"HW2 JTAG SHIFT %s, length %d from %s to %s then %s stat %s\n",
+		"HW2 JTAG SHIFT %s, length %d status %s from %s to %s then %s pad 0x%x\n",
 		(xfer->type == JTAG_SIR_XFER) ? "IR" : "DR", xfer->length,
-		end_status_str[xfer->from], end_status_str[shift],
-		end_status_str[xfer->endstate],
-		end_status_str[aspeed_jtag->status]);
+		end_status_str[aspeed_jtag->current_state],
+		end_status_str[xfer->from],
+		end_status_str[shift],
+		end_status_str[xfer->endstate], xfer->padding);
 #endif

-	if (xfer->from == shift) {
+	if (aspeed_jtag->current_state == shift) {
 		start_shift = 0;
-	} else {
-		reg_val = aspeed_jtag_read(aspeed_jtag, ASPEED_JTAG_GBLCTRL);
-		aspeed_jtag_write(aspeed_jtag,
-				  reg_val | ASPEED_JTAG_GBLCTRL_RESET_FIFO,
-				  ASPEED_JTAG_GBLCTRL);
+	} else if (aspeed_jtag->current_state == JTAG_STATE_IDLE ||
+		   aspeed_jtag->current_state == JTAG_STATE_TLRESET ||
+		   aspeed_jtag->current_state == pause) {
 		start_shift = ASPEED_JTAG_SHCTRL_START_SHIFT;
+	} else {
+		return -EINVAL;
 	}

-	if (xfer->endstate == shift)
-		end_shift = 0;
-	else
+	if (xfer->endstate == shift) {
+		/*
+		 * In the case of shifting 1 bit of data and attempting to stay
+		 * in the SHIFT state, the AST2600 JTAG Master Controller in
+		 * Hardware mode 2 has been observed to go to EXIT1 IR/DR
+		 * instead of staying in the SHIFT IR/DR state. The following
+		 * code special cases this one bit shift and directs the state
+		 * machine to go to the PAUSE IR/DR state instead.
+		 * Alternatively, the application making driver calls can avoid
+		 * this situation as follows:
+		 *   1.) Bundle all of the shift bits  together into one call
+		 *       AND/OR
+		 *   2.) Direct all partial shifts to move to the PAUSE-IR/DR
+		 *       state.
+		 */
+		if (xfer->length == 1) {
+#ifdef DEBUG_JTAG
+			dev_warn(aspeed_jtag->dev, "JTAG Silicon WA: going to pause instead of shift");
+#endif
+			end_shift = ASPEED_JTAG_SHCTRL_END_SHIFT;
+			endstate = pause;
+		} else {
+			end_shift = 0;
+			endstate = shift;
+		}
+	} else if (xfer->endstate == exit) {
+		endstate = JTAG_STATE_IDLE;
 		end_shift = ASPEED_JTAG_SHCTRL_END_SHIFT;
+	} else if (xfer->endstate == JTAG_STATE_IDLE) {
+		endstate = JTAG_STATE_IDLE;
+		end_shift = ASPEED_JTAG_SHCTRL_END_SHIFT;
+	} else if (xfer->endstate == pause) {
+		endstate = pause;
+		end_shift = ASPEED_JTAG_SHCTRL_END_SHIFT;
+	} else {
+		return -EINVAL;
+	}
+
+	aspeed_jtag_write(aspeed_jtag, xfer->padding, ASPEED_JTAG_PADCTRL0);

 	while (remain_xfer) {
 		unsigned long partial_xfer;
@@ -1176,6 +1154,17 @@ static int aspeed_jtag_xfer_hw2(struct aspeed_jtag *aspeed_jtag,

 		partial_index = index;
 		partial_xfer = partial_xfer_size;
+
+		reg_val = aspeed_jtag_read(aspeed_jtag, ASPEED_JTAG_GBLCTRL);
+		aspeed_jtag_write(aspeed_jtag, reg_val |
+				  ASPEED_JTAG_GBLCTRL_RESET_FIFO,
+				  ASPEED_JTAG_GBLCTRL);
+
+		/* Switch internal FIFO into CPU mode */
+		reg_val = reg_val & ~BIT(24);
+		aspeed_jtag_write(aspeed_jtag, reg_val,
+				  ASPEED_JTAG_GBLCTRL);
+
 		while (partial_xfer) {
 			if (partial_xfer > ASPEED_JTAG_DATA_CHUNK_SIZE)
 				shift_bits = ASPEED_JTAG_DATA_CHUNK_SIZE;
@@ -1188,6 +1177,8 @@ static int aspeed_jtag_xfer_hw2(struct aspeed_jtag *aspeed_jtag,
 						  data_reg);
 			else
 				aspeed_jtag_write(aspeed_jtag, 0, data_reg);
+			if (aspeed_jtag->llops->xfer_hw_fifo_delay)
+				aspeed_jtag->llops->xfer_hw_fifo_delay();
 			partial_xfer = partial_xfer - shift_bits;
 		}
 		if (remain_xfer > ASPEED_JTAG_HW2_DATA_CHUNK_SIZE) {
@@ -1198,9 +1189,9 @@ static int aspeed_jtag_xfer_hw2(struct aspeed_jtag *aspeed_jtag,
 			 * and after the transfer go to Pause IR/DR.
 			 */

-			aspeed_jtag_shctrl_tms_mask(xfer->from, shift, exit,
-						    xfer->endstate, start_shift,
-						    0, &tms_mask);
+			aspeed_jtag_shctrl_tms_mask(aspeed_jtag->current_state,
+						    shift, exit, endstate,
+						    start_shift, 0, &tms_mask);

 			reg_val = aspeed_jtag_read(aspeed_jtag,
 						   ASPEED_JTAG_GBLCTRL);
@@ -1220,9 +1211,10 @@ static int aspeed_jtag_xfer_hw2(struct aspeed_jtag *aspeed_jtag,
 			 * Read bytes equals to column length
 			 */
 			shift_bits = remain_xfer;
-			aspeed_jtag_shctrl_tms_mask(xfer->from, shift, exit,
-						    xfer->endstate, start_shift,
-						    end_shift, &tms_mask);
+			aspeed_jtag_shctrl_tms_mask(aspeed_jtag->current_state,
+						    shift, exit, endstate,
+						    start_shift, end_shift,
+						    &tms_mask);

 			reg_val = aspeed_jtag_read(aspeed_jtag,
 						   ASPEED_JTAG_GBLCTRL);
@@ -1241,33 +1233,33 @@ static int aspeed_jtag_xfer_hw2(struct aspeed_jtag *aspeed_jtag,
 			aspeed_jtag_wait_shift_complete(aspeed_jtag);
 		}

-		if (xfer->direction & JTAG_READ_XFER) {
-			partial_index = index;
-			partial_xfer = partial_xfer_size;
-			while (partial_xfer) {
-				if (partial_xfer >
-				    ASPEED_JTAG_DATA_CHUNK_SIZE) {
-					shift_bits =
-						ASPEED_JTAG_DATA_CHUNK_SIZE;
-					data[partial_index++] =
-						aspeed_jtag_read(aspeed_jtag,
-								 data_reg);
-
-				} else {
-					shift_bits = partial_xfer;
-					data[partial_index++] =
-						aspeed_jtag_read(aspeed_jtag,
-								 data_reg);
-				}
-				partial_xfer = partial_xfer - shift_bits;
+		partial_index = index;
+		partial_xfer = partial_xfer_size;
+		while (partial_xfer) {
+			if (partial_xfer >
+			    ASPEED_JTAG_DATA_CHUNK_SIZE) {
+				shift_bits =
+					ASPEED_JTAG_DATA_CHUNK_SIZE;
+				data[partial_index++] =
+					aspeed_jtag_read(aspeed_jtag,
+							 data_reg);
+
+			} else {
+				shift_bits = partial_xfer;
+				data[partial_index++] =
+					aspeed_jtag_read(aspeed_jtag,
+							 data_reg);
 			}
+			if (aspeed_jtag->llops->xfer_hw_fifo_delay)
+				aspeed_jtag->llops->xfer_hw_fifo_delay();
+			partial_xfer = partial_xfer - shift_bits;
 		}

 		remain_xfer = remain_xfer - partial_xfer_size;
 		index = partial_index;
 		start_shift = 0;
 	}
-	aspeed_jtag->status = xfer->endstate;
+	aspeed_jtag->current_state = endstate;
 	return 0;
 }

@@ -1275,15 +1267,14 @@ static int aspeed_jtag_status_get(struct jtag *jtag, u32 *status)
 {
 	struct aspeed_jtag *aspeed_jtag = jtag_priv(jtag);

-	*status = aspeed_jtag->status;
+	*status = aspeed_jtag->current_state;
 	return 0;
 }

-#ifdef USE_INTERRUPTS
 static irqreturn_t aspeed_jtag_interrupt(s32 this_irq, void *dev_id)
 {
 	struct aspeed_jtag *aspeed_jtag = dev_id;
-	irqreturn_t ret = IRQ_HANDLED;
+	irqreturn_t ret;
 	u32 status;

 	status = aspeed_jtag_read(aspeed_jtag, ASPEED_JTAG_ISR);
@@ -1306,7 +1297,31 @@ static irqreturn_t aspeed_jtag_interrupt(s32 this_irq, void *dev_id)
 	}
 	return ret;
 }
-#endif
+
+static irqreturn_t aspeed_jtag_interrupt_hw2(s32 this_irq, void *dev_id)
+{
+	struct aspeed_jtag *aspeed_jtag = dev_id;
+	irqreturn_t ret;
+	u32 status;
+
+	status = aspeed_jtag_read(aspeed_jtag, ASPEED_JTAG_INTCTRL);
+
+	if (status & ASPEED_JTAG_INTCTRL_SHCPL_IRQ_STAT) {
+		aspeed_jtag_write(aspeed_jtag,
+				  status | ASPEED_JTAG_INTCTRL_SHCPL_IRQ_STAT,
+				  ASPEED_JTAG_INTCTRL);
+		aspeed_jtag->flag |= status & ASPEED_JTAG_INTCTRL_SHCPL_IRQ_STAT;
+	}
+
+	if (aspeed_jtag->flag) {
+		wake_up_interruptible(&aspeed_jtag->jtag_wq);
+		ret = IRQ_HANDLED;
+	} else {
+		dev_err(aspeed_jtag->dev, "irq status:%x\n", status);
+		ret = IRQ_NONE;
+	}
+	return ret;
+}

 static int aspeed_jtag_enable(struct jtag *jtag)
 {
@@ -1331,6 +1346,10 @@ static int aspeed_jtag_init(struct platform_device *pdev,
 #ifdef USE_INTERRUPTS
 	int err;
 #endif
+	memset(aspeed_jtag->pad_data_one, ~0,
+	       sizeof(aspeed_jtag->pad_data_one));
+	memset(aspeed_jtag->pad_data_zero, 0,
+	       sizeof(aspeed_jtag->pad_data_zero));

 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	aspeed_jtag->reg_base = devm_ioremap_resource(aspeed_jtag->dev, res);
@@ -1366,8 +1385,8 @@ static int aspeed_jtag_init(struct platform_device *pdev,

 #ifdef USE_INTERRUPTS
 	err = devm_request_irq(aspeed_jtag->dev, aspeed_jtag->irq,
-			       aspeed_jtag_interrupt, 0, "aspeed-jtag",
-			       aspeed_jtag);
+			       aspeed_jtag->llops->jtag_interrupt, 0,
+			       "aspeed-jtag", aspeed_jtag);
 	if (err) {
 		dev_err(aspeed_jtag->dev, "unable to get IRQ");
 		clk_disable_unprepare(aspeed_jtag->pclk);
@@ -1403,7 +1422,7 @@ static const struct jtag_ops aspeed_jtag_ops = {
 	.mode_set = aspeed_jtag_mode_set,
 	.bitbang = aspeed_jtag_bitbang,
 	.enable = aspeed_jtag_enable,
-	.disable = aspeed_jtag_disable,
+	.disable = aspeed_jtag_disable
 };

 static const struct jtag_ops aspeed_jtag_ops_26xx = {
@@ -1431,7 +1450,10 @@ static const struct jtag_low_level_functions ast25xx_llops = {
 	.xfer_push_data = aspeed_jtag_xfer_push_data,
 	.xfer_push_data_last = aspeed_jtag_xfer_push_data_last,
 	.xfer_sw = aspeed_jtag_xfer_sw,
-	.xfer_hw = aspeed_jtag_xfer_hw
+	.xfer_hw = aspeed_jtag_xfer_hw,
+	.xfer_hw_fifo_delay = NULL,
+	.xfer_sw_delay = NULL,
+	.jtag_interrupt = aspeed_jtag_interrupt
 };

 static const struct aspeed_jtag_functions ast25xx_functions = {
@@ -1446,14 +1468,20 @@ static const struct jtag_low_level_functions ast26xx_llops = {
 	.xfer_push_data = aspeed_jtag_xfer_push_data_26xx,
 	.xfer_push_data_last = aspeed_jtag_xfer_push_data_last_26xx,
 	.xfer_sw = aspeed_jtag_xfer_sw,
-	.xfer_hw = aspeed_jtag_xfer_hw2
+	.xfer_hw = aspeed_jtag_xfer_hw2,
+	.xfer_hw_fifo_delay = aspeed_jtag_xfer_hw_fifo_delay_26xx,
+	.xfer_sw_delay = aspeed_jtag_sw_delay_26xx,
+	.jtag_interrupt = aspeed_jtag_interrupt_hw2
 #else
 	.master_enable = aspeed_jtag_master,
 	.output_disable = aspeed_jtag_output_disable,
 	.xfer_push_data = aspeed_jtag_xfer_push_data_26xx,
 	.xfer_push_data_last = aspeed_jtag_xfer_push_data_last_26xx,
 	.xfer_sw = aspeed_jtag_xfer_sw,
-	.xfer_hw = aspeed_jtag_xfer_hw
+	.xfer_hw = aspeed_jtag_xfer_hw,
+	.xfer_hw_fifo_delay = aspeed_jtag_xfer_hw_fifo_delay_26xx,
+	.xfer_sw_delay = aspeed_jtag_sw_delay_26xx,
+	.jtag_interrupt = aspeed_jtag_interrupt
 #endif
 };

diff --git a/drivers/jtag/jtag.c b/drivers/jtag/jtag.c
index 27c204bd9e6b..39a4d88a9c21 100644
--- a/drivers/jtag/jtag.c
+++ b/drivers/jtag/jtag.c
@@ -172,6 +172,7 @@ static long jtag_ioctl(struct file *file, unsigned int cmd, unsigned long arg)

 		err = jtag->ops->mode_set(jtag, &mode);
 		break;
+
 	default:
 		return -EINVAL;
 	}
diff --git a/include/uapi/linux/jtag.h b/include/uapi/linux/jtag.h
index af6ac3d097a3..1e630124ad80 100644
--- a/include/uapi/linux/jtag.h
+++ b/include/uapi/linux/jtag.h
@@ -132,6 +132,27 @@ struct jtag_tap_state {
 	__u8	tck;
 };

+/**
+ * union pad_config - Padding Configuration:
+ *
+ * @type: transfer type
+ * @pre_pad_number: Number of prepadding bits bit[11:0]
+ * @post_pad_number: Number of prepadding bits bit[23:12]
+ * @pad_data : Bit value to be used by pre and post padding bit[24]
+ * @int_value: unsigned int packed padding configuration value bit[32:0]
+ *
+ * Structure provide pre and post padding configuration in a single __u32
+ */
+union pad_config {
+	struct {
+		__u32 pre_pad_number	: 12;
+		__u32 post_pad_number	: 12;
+		__u32 pad_data		: 1;
+		__u32 rsvd		: 7;
+	};
+	__u32 int_value;
+};
+
 /**
  * struct jtag_xfer - jtag xfer:
  *
@@ -150,7 +171,7 @@ struct jtag_xfer {
 	__u8	direction;
 	__u8	from;
 	__u8	endstate;
-	__u8	padding;
+	__u32	padding;
 	__u32	length;
 	__u64	tdio;
 };
@@ -211,4 +232,135 @@ struct jtag_mode {
 #define JTAG_SIOCMODE	_IOW(__JTAG_IOCTL_MAGIC, 5, struct jtag_mode)
 #define JTAG_IOCBITBANG	_IOWR(__JTAG_IOCTL_MAGIC, 6, struct bitbang_packet)

+/**
+ * struct tms_cycle - This structure represents a tms cycle state.
+ *
+ * @tmsbits: is the bitwise representation of the needed tms transitions to
+ *           move from one state to another.
+ * @count:   number of jumps needed to move to the needed state.
+ *
+ */
+struct tms_cycle {
+	unsigned char tmsbits;
+	unsigned char count;
+};
+
+/*
+ * This is the complete set TMS cycles for going from any TAP state to any
+ * other TAP state, following a "shortest path" rule.
+ */
+static const struct tms_cycle _tms_cycle_lookup[][16] = {
+/*	    TLR        RTI        SelDR      CapDR      SDR        Ex1DR*/
+/* TLR  */{{0x00, 0}, {0x00, 1}, {0x02, 2}, {0x02, 3}, {0x02, 4}, {0x0a, 4},
+/*	    PDR        Ex2DR      UpdDR      SelIR      CapIR      SIR*/
+	    {0x0a, 5}, {0x2a, 6}, {0x1a, 5}, {0x06, 3}, {0x06, 4}, {0x06, 5},
+/*	    Ex1IR      PIR        Ex2IR      UpdIR*/
+	    {0x16, 5}, {0x16, 6}, {0x56, 7}, {0x36, 6} },
+
+/*	    TLR        RTI        SelDR      CapDR      SDR        Ex1DR*/
+/* RTI  */{{0x07, 3}, {0x00, 0}, {0x01, 1}, {0x01, 2}, {0x01, 3}, {0x05, 3},
+/*	    PDR        Ex2DR      UpdDR      SelIR      CapIR      SIR*/
+	    {0x05, 4}, {0x15, 5}, {0x0d, 4}, {0x03, 2}, {0x03, 3}, {0x03, 4},
+/*	    Ex1IR      PIR        Ex2IR      UpdIR*/
+	    {0x0b, 4}, {0x0b, 5}, {0x2b, 6}, {0x1b, 5} },
+
+/*	    TLR        RTI        SelDR      CapDR      SDR        Ex1DR*/
+/* SelDR*/{{0x03, 2}, {0x03, 3}, {0x00, 0}, {0x00, 1}, {0x00, 2}, {0x02, 2},
+/*	    PDR        Ex2DR      UpdDR      SelIR      CapIR      SIR*/
+	    {0x02, 3}, {0x0a, 4}, {0x06, 3}, {0x01, 1}, {0x01, 2}, {0x01, 3},
+/*	    Ex1IR      PIR        Ex2IR      UpdIR*/
+	    {0x05, 3}, {0x05, 4}, {0x15, 5}, {0x0d, 4} },
+
+/*	    TLR        RTI        SelDR      CapDR      SDR        Ex1DR*/
+/* CapDR*/{{0x1f, 5}, {0x03, 3}, {0x07, 3}, {0x00, 0}, {0x00, 1}, {0x01, 1},
+/*	    PDR        Ex2DR      UpdDR      SelIR      CapIR      SIR*/
+	    {0x01, 2}, {0x05, 3}, {0x03, 2}, {0x0f, 4}, {0x0f, 5}, {0x0f, 6},
+/*	    Ex1IR      PIR        Ex2IR      UpdIR*/
+	    {0x2f, 6}, {0x2f, 7}, {0xaf, 8}, {0x6f, 7} },
+
+/*	    TLR        RTI        SelDR      CapDR      SDR        Ex1DR*/
+/* SDR  */{{0x1f, 5}, {0x03, 3}, {0x07, 3}, {0x07, 4}, {0x00, 0}, {0x01, 1},
+/*	    PDR        Ex2DR      UpdDR      SelIR      CapIR      SIR*/
+	    {0x01, 2}, {0x05, 3}, {0x03, 2}, {0x0f, 4}, {0x0f, 5}, {0x0f, 6},
+/*	    Ex1IR      PIR        Ex2IR      UpdIR*/
+	    {0x2f, 6}, {0x2f, 7}, {0xaf, 8}, {0x6f, 7} },
+
+/*	    TLR        RTI        SelDR      CapDR      SDR        Ex1DR*/
+/* Ex1DR*/{{0x0f, 4}, {0x01, 2}, {0x03, 2}, {0x03, 3}, {0x02, 3}, {0x00, 0},
+/*	    PDR        Ex2DR      UpdDR      SelIR      CapIR      SIR*/
+	    {0x00, 1}, {0x02, 2}, {0x01, 1}, {0x07, 3}, {0x07, 4}, {0x07, 5},
+/*	    Ex1IR      PIR        Ex2IR      UpdIR*/
+	    {0x17, 5}, {0x17, 6}, {0x57, 7}, {0x37, 6} },
+
+/*	    TLR        RTI        SelDR      CapDR      SDR        Ex1DR*/
+/* PDR  */{{0x1f, 5}, {0x03, 3}, {0x07, 3}, {0x07, 4}, {0x01, 2}, {0x05, 3},
+/*	    PDR        Ex2DR      UpdDR      SelIR      CapIR      SIR*/
+	    {0x00, 0}, {0x01, 1}, {0x03, 2}, {0x0f, 4}, {0x0f, 5}, {0x0f, 6},
+/*	    Ex1IR      PIR        Ex2IR      UpdIR*/
+	    {0x2f, 6}, {0x2f, 7}, {0xaf, 8}, {0x6f, 7} },
+
+/*	    TLR        RTI        SelDR      CapDR      SDR        Ex1DR*/
+/* Ex2DR*/{{0x0f, 4}, {0x01, 2}, {0x03, 2}, {0x03, 3}, {0x00, 1}, {0x02, 2},
+/*	    PDR        Ex2DR      UpdDR      SelIR      CapIR      SIR*/
+	    {0x02, 3}, {0x00, 0}, {0x01, 1}, {0x07, 3}, {0x07, 4}, {0x07, 5},
+/*	    Ex1IR      PIR        Ex2IR      UpdIR*/
+	    {0x17, 5}, {0x17, 6}, {0x57, 7}, {0x37, 6} },
+
+/*	    TLR        RTI        SelDR      CapDR      SDR        Ex1DR*/
+/* UpdDR*/{{0x07, 3}, {0x00, 1}, {0x01, 1}, {0x01, 2}, {0x01, 3}, {0x05, 3},
+/*	    PDR        Ex2DR      UpdDR      SelIR      CapIR      SIR*/
+	    {0x05, 4}, {0x15, 5}, {0x00, 0}, {0x03, 2}, {0x03, 3}, {0x03, 4},
+/*	    Ex1IR      PIR        Ex2IR      UpdIR*/
+	    {0x0b, 4}, {0x0b, 5}, {0x2b, 6}, {0x1b, 5} },
+
+/*	    TLR        RTI        SelDR      CapDR      SDR        Ex1DR*/
+/* SelIR*/{{0x01, 1}, {0x01, 2}, {0x05, 3}, {0x05, 4}, {0x05, 5}, {0x15, 5},
+/*	    PDR        Ex2DR      UpdDR      SelIR      CapIR      SIR*/
+	    {0x15, 6}, {0x55, 7}, {0x35, 6}, {0x00, 0}, {0x00, 1}, {0x00, 2},
+/*	    Ex1IR      PIR        Ex2IR      UpdIR*/
+	    {0x02, 2}, {0x02, 3}, {0x0a, 4}, {0x06, 3} },
+
+/*	    TLR        RTI        SelDR      CapDR      SDR        Ex1DR*/
+/* CapIR*/{{0x1f, 5}, {0x03, 3}, {0x07, 3}, {0x07, 4}, {0x07, 5}, {0x17, 5},
+/*	    PDR        Ex2DR      UpdDR      SelIR      CapIR      SIR*/
+	    {0x17, 6}, {0x57, 7}, {0x37, 6}, {0x0f, 4}, {0x00, 0}, {0x00, 1},
+/*	    Ex1IR      PIR        Ex2IR      UpdIR*/
+	    {0x01, 1}, {0x01, 2}, {0x05, 3}, {0x03, 2} },
+
+/*	    TLR        RTI        SelDR      CapDR      SDR        Ex1DR*/
+/* SIR  */{{0x1f, 5}, {0x03, 3}, {0x07, 3}, {0x07, 4}, {0x07, 5}, {0x17, 5},
+/*	    PDR        Ex2DR      UpdDR      SelIR      CapIR      SIR*/
+	    {0x17, 6}, {0x57, 7}, {0x37, 6}, {0x0f, 4}, {0x0f, 5}, {0x00, 0},
+/*	    Ex1IR      PIR        Ex2IR      UpdIR*/
+	    {0x01, 1}, {0x01, 2}, {0x05, 3}, {0x03, 2} },
+
+/*	    TLR        RTI        SelDR      CapDR      SDR        Ex1DR*/
+/* Ex1IR*/{{0x0f, 4}, {0x01, 2}, {0x03, 2}, {0x03, 3}, {0x03, 4}, {0x0b, 4},
+/*	    PDR        Ex2DR      UpdDR      SelIR      CapIR      SIR*/
+	    {0x0b, 5}, {0x2b, 6}, {0x1b, 5}, {0x07, 3}, {0x07, 4}, {0x02, 3},
+/*	    Ex1IR      PIR        Ex2IR      UpdIR*/
+	    {0x00, 0}, {0x00, 1}, {0x02, 2}, {0x01, 1} },
+
+/*	    TLR        RTI        SelDR      CapDR      SDR        Ex1DR*/
+/* PIR  */{{0x1f, 5}, {0x03, 3}, {0x07, 3}, {0x07, 4}, {0x07, 5}, {0x17, 5},
+/*	    PDR        Ex2DR      UpdDR      SelIR      CapIR      SIR*/
+	    {0x17, 6}, {0x57, 7}, {0x37, 6}, {0x0f, 4}, {0x0f, 5}, {0x01, 2},
+/*	    Ex1IR      PIR        Ex2IR      UpdIR*/
+	    {0x05, 3}, {0x00, 0}, {0x01, 1}, {0x03, 2} },
+
+/*	    TLR        RTI        SelDR      CapDR      SDR        Ex1DR*/
+/* Ex2IR*/{{0x0f, 4}, {0x01, 2}, {0x03, 2}, {0x03, 3}, {0x03, 4}, {0x0b, 4},
+/*	    PDR        Ex2DR      UpdDR      SelIR      CapIR      SIR*/
+	    {0x0b, 5}, {0x2b, 6}, {0x1b, 5}, {0x07, 3}, {0x07, 4}, {0x00, 1},
+/*	    Ex1IR      PIR        Ex2IR      UpdIR*/
+	    {0x02, 2}, {0x02, 3}, {0x00, 0}, {0x01, 1} },
+
+/*	    TLR        RTI        SelDR      CapDR      SDR        Ex1DR*/
+/* UpdIR*/{{0x07, 3}, {0x00, 1}, {0x01, 1}, {0x01, 2}, {0x01, 3}, {0x05, 3},
+/*	    PDR        Ex2DR      UpdDR      SelIR      CapIR      SIR*/
+	    {0x05, 4}, {0x15, 5}, {0x0d, 4}, {0x03, 2}, {0x03, 3}, {0x03, 4},
+/*	    Ex1IR      PIR        Ex2IR      UpdIR*/
+	    {0x0b, 4}, {0x0b, 5}, {0x2b, 6}, {0x00, 0} },
+};
+
 #endif /* __UAPI_LINUX_JTAG_H */
--
2.17.1

