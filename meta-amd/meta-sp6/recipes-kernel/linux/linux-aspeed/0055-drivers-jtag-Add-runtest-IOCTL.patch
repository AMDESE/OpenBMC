From f325ec19e721477442eaec6005a63fdf74c32815 Mon Sep 17 00:00:00 2001
From: Supreeth Venkatesh <supreeth.venkatesh@amd.com>
Date: Fri, 3 Dec 2021 18:24:01 -0600
Subject: [PATCH 1/1] drivers/jtag: Add runtest IOCTL
Content-Type: text/plain; charset="us-ascii"
Content-Transfer-Encoding: 7bit

Adds runtest IOCTL workaround to get around AMD JTAG IP limitation which
requires pre-determined number of tck cycles to be run in run test idle
state [RTI] before and after shift operation.

Signed-off-by: Pete Jakobsen <pete.jakobsen@amd.com>
Signed-off-by: Supreeth Venkatesh <supreeth.venkatesh@amd.com>
---
 drivers/jtag/jtag-aspeed.c | 83 +++++++++++++++++++++++++++++++++-----
 drivers/jtag/jtag.c        |  4 +-
 include/linux/jtag.h       |  2 +
 include/uapi/linux/jtag.h  |  1 +
 4 files changed, 78 insertions(+), 12 deletions(-)

diff --git a/drivers/jtag/jtag-aspeed.c b/drivers/jtag/jtag-aspeed.c
index 90e50a933298..535eb363ed72 100644
--- a/drivers/jtag/jtag-aspeed.c
+++ b/drivers/jtag/jtag-aspeed.c
@@ -16,6 +16,7 @@
 #include <linux/types.h>
 #include <linux/delay.h>
 #include <uapi/linux/jtag.h>
+#include <linux/printk.h>

 #define ASPEED_JTAG_DATA		0x00
 #define ASPEED_JTAG_INST		0x04
@@ -99,10 +100,10 @@

 #define ASPEED_JTAG_TCK_WAIT		10
 #define ASPEED_JTAG_RESET_CNTR		10
-#define WAIT_ITERATIONS		300
+#define WAIT_ITERATIONS		3000000

 /* Use this macro to switch between HW mode 1(comment out) and 2(defined)  */
-//#define ASPEED_JTAG_HW_MODE_2_ENABLE	1
+#define ASPEED_JTAG_HW_MODE_2_ENABLE	1

 /* ASPEED JTAG HW MODE 2 (Only supported in AST26xx series) */
 #define ASPEED_JTAG_SHDATA		0x20
@@ -161,7 +162,7 @@
 /* Use this macro to set us delay for JTAG Master Controller to be programmed */
 #define AST26XX_JTAG_CTRL_UDELAY	2

-#define USE_INTERRUPTS
+//#define USE_INTERRUPTS
 #define DEBUG_JTAG

 static const char * const regnames[] = {
@@ -271,6 +272,8 @@ static int aspeed_jtag_freq_set(struct jtag *jtag, u32 freq)
 	aspeed_jtag_write(aspeed_jtag,
 			  (tck_val & ~ASPEED_JTAG_TCK_DIVISOR_MASK) | div,
 			  ASPEED_JTAG_TCK);
+  tck_val = aspeed_jtag_read(aspeed_jtag, ASPEED_JTAG_TCK) & 0x0fff;
+	printk( "freq_set_25xx apb_freq=%lu freq=%u div=%d tck_val=%u\n", apb_frq, freq, div, tck_val );
 	return 0;
 }

@@ -293,6 +296,9 @@ static int aspeed_jtag_freq_set_26xx(struct jtag *jtag, u32 freq)
 	aspeed_jtag_write(aspeed_jtag,
 			  (tck_val & ~ASPEED_JTAG_CLK_DIVISOR_MASK) | div,
 			  ASPEED_JTAG_GBLCTRL);
+  tck_val = aspeed_jtag_read(aspeed_jtag, ASPEED_JTAG_GBLCTRL) & 0x0fff;
+	printk( "freq_set_26xx apb_freq=%lu freq=%u div=%d tck_val=%u\n", apb_frq, freq, div, tck_val );
+	return aspeed_jtag_freq_set( jtag, freq );
 	return 0;
 }

@@ -477,6 +483,16 @@ static int aspeed_jtag_bitbang(struct jtag *jtag,
 	return 0;
 }

+/* Run in current state for specific number of tcks */
+static int aspeed_jtag_runtest(struct jtag *jtag, unsigned int tcks) {
+	struct aspeed_jtag *aspeed_jtag = jtag_priv(jtag);
+  for ( ; tcks; --tcks ) {
+		aspeed_jtag_tck_cycle(aspeed_jtag, 0, 0); // TMS=0, TDI=0
+	}
+
+	return 0;
+}
+
 static inline void aspeed_jtag_xfer_hw_fifo_delay_26xx(void)
 {
 	udelay(AST26XX_FIFO_UDELAY);
@@ -507,10 +523,10 @@ static int aspeed_jtag_isr_wait(struct aspeed_jtag *aspeed_jtag, u32 bit)
 			break;
 		}
 		if ((status & ASPEED_JTAG_ISR_DATA_COMPLETE) == 0) {
-			if (iterations % 25 == 0)
-				usleep_range(1, 5);
-			else
-				udelay(1);
+		// 	if (iterations % 25 == 0)
+		// 		usleep_range(1, 5);
+		// 	else
+		 		udelay(1);
 		}
 	}
 	aspeed_jtag_write(aspeed_jtag, bit | (status & 0xf), ASPEED_JTAG_ISR);
@@ -542,9 +558,9 @@ static int aspeed_jtag_wait_shift_complete(struct aspeed_jtag *aspeed_jtag)
 			res = -EFAULT;
 			break;
 		}
-		if (iterations % 25 == 0)
-			usleep_range(1, 5);
-		else
+		// if (iterations % 25 == 0)
+		// 	usleep_range(1, 5);
+		// else
 			udelay(1);
 	}
 	aspeed_jtag_write(aspeed_jtag,
@@ -555,6 +571,48 @@ static int aspeed_jtag_wait_shift_complete(struct aspeed_jtag *aspeed_jtag)
 	return res;
 }

+/* Run in current state for specific number of tcks
+
+  To toggle 123 cycles, it can be composed by no Pre-TMS, Shift of 123 bits, no Post-TMS.
+  Pre-TMS: JTAG30[12:10]; Shift: JTAG34[22:20], JTAG30[6:0]; Post-TMS: JTAG30[15:13].
+  In this configuration, since it starts at RTI, TMS keeps 0; TCK toggles 123 cycles;
+	DataOut is sending what is written to JTAG00/04.
+
+ */
+static int aspeed_jtag_runtest_26xx(struct jtag *jtag, unsigned int tcks) {
+	u32 shctrl;
+	u32 gblctrl;
+	struct aspeed_jtag *aspeed_jtag = jtag_priv(jtag);
+
+  //shctrl  = aspeed_jtag_read( aspeed_jtag, ASPEED_JTAG_SHCTRL  );
+  gblctrl = aspeed_jtag_read( aspeed_jtag, ASPEED_JTAG_GBLCTRL );
+
+  while ( tcks ) {
+		const u32 five_twelve = 512;
+    shctrl  = 0; //~0x3FFFFC7F; // Clear TMS Value Post TMS, Pre TMS, Lower Data Shift Number
+	  gblctrl &= ~( 0x7 << 20 ); // Clear Upper Data shift number
+
+    if ( tcks > 512 ) {
+	    shctrl  |= (0x7F & five_twelve); // Set lower data shift number
+      gblctrl |= (( five_twelve >> 7 ) & 0x3 ) << 20; // We can only go to 512 so  truncate
+			tcks -= five_twelve;
+
+		} else {
+      shctrl  |= (0x7F & tcks); // Set lower data shift number
+      gblctrl |= (( tcks >> 7 ) & 0x3 ) << 20; // We can only go to 512 so  truncate
+			tcks = 0;
+		}
+
+		//printk( "JTAG_SHCTRL =0x%08X\n", shctrl );
+		//printk( "JTAG_GBLCTRL=0x%08X\n", gblctrl );
+	  aspeed_jtag_write(aspeed_jtag, shctrl,  ASPEED_JTAG_SHCTRL  );
+	  aspeed_jtag_write(aspeed_jtag, gblctrl, ASPEED_JTAG_GBLCTRL );
+		aspeed_jtag_wait_shift_complete( aspeed_jtag );
+	}
+	return 0;
+}
+
+
 static void aspeed_jtag_set_tap_state(struct aspeed_jtag *aspeed_jtag,
 				      enum jtag_tapstate from_state,
 				      enum jtag_tapstate end_state)
@@ -1422,7 +1480,8 @@ static const struct jtag_ops aspeed_jtag_ops = {
 	.mode_set = aspeed_jtag_mode_set,
 	.bitbang = aspeed_jtag_bitbang,
 	.enable = aspeed_jtag_enable,
-	.disable = aspeed_jtag_disable
+	.disable = aspeed_jtag_disable,
+	.runtest = aspeed_jtag_runtest
 };

 static const struct jtag_ops aspeed_jtag_ops_26xx = {
@@ -1431,11 +1490,13 @@ static const struct jtag_ops aspeed_jtag_ops_26xx = {
 	.freq_set = aspeed_jtag_freq_set_26xx,
 	.status_get = aspeed_jtag_status_get,
 	.status_set = aspeed_jtag_status_set_26xx,
+	.runtest = aspeed_jtag_runtest_26xx,
 #else
 	.freq_get = aspeed_jtag_freq_get,
 	.freq_set = aspeed_jtag_freq_set,
 	.status_get = aspeed_jtag_status_get,
 	.status_set = aspeed_jtag_status_set,
+	.runtest = aspeed_jtag_runtest,
 #endif
 	.xfer = aspeed_jtag_xfer,
 	.mode_set = aspeed_jtag_mode_set,
diff --git a/drivers/jtag/jtag.c b/drivers/jtag/jtag.c
index 39a4d88a9c21..da22805f5a7c 100644
--- a/drivers/jtag/jtag.c
+++ b/drivers/jtag/jtag.c
@@ -172,7 +172,9 @@ static long jtag_ioctl(struct file *file, unsigned int cmd, unsigned long arg)

 		err = jtag->ops->mode_set(jtag, &mode);
 		break;
-
+	case JTAG_RUNTEST:
+		err = jtag->ops->runtest(jtag, (unsigned int)arg);
+		break;
 	default:
 		return -EINVAL;
 	}
diff --git a/include/linux/jtag.h b/include/linux/jtag.h
index 112bb90029a9..9ef75fab111d 100644
--- a/include/linux/jtag.h
+++ b/include/linux/jtag.h
@@ -24,6 +24,7 @@ struct jtag;
  * @bitbang: set low level bitbang operations. Filled by dev driver
  * @enable: enables JTAG interface in master mode. Filled by dev driver
  * @disable: disables JTAG interface master mode. Filled by dev driver
+ * @runtest: Issue count TCK pulses
  */
 struct jtag_ops {
 	int (*freq_get)(struct jtag *jtag, u32 *freq);
@@ -36,6 +37,7 @@ struct jtag_ops {
 		       struct tck_bitbang *bitbang_data);
 	int (*enable)(struct jtag *jtag);
 	int (*disable)(struct jtag *jtag);
+	int (*runtest)(struct jtag *jtag, u32 count);
 };

 void *jtag_priv(struct jtag *jtag);
diff --git a/include/uapi/linux/jtag.h b/include/uapi/linux/jtag.h
index 1e630124ad80..49d0c84b324f 100644
--- a/include/uapi/linux/jtag.h
+++ b/include/uapi/linux/jtag.h
@@ -231,6 +231,7 @@ struct jtag_mode {
 #define JTAG_GIOCSTATUS _IOWR(__JTAG_IOCTL_MAGIC, 4, enum jtag_tapstate)
 #define JTAG_SIOCMODE	_IOW(__JTAG_IOCTL_MAGIC, 5, struct jtag_mode)
 #define JTAG_IOCBITBANG	_IOWR(__JTAG_IOCTL_MAGIC, 6, struct bitbang_packet)
+#define JTAG_RUNTEST    _IOW(__JTAG_IOCTL_MAGIC, 7, unsigned int)

 /**
  * struct tms_cycle - This structure represents a tms cycle state.
--
2.17.1

